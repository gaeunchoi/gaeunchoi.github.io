[ { "title": "[Python] BOJ 5430 AC", "url": "/posts/BOJ5430/", "categories": "Study, BOJ", "tags": "python, algorithm, BOJ", "date": "2022-07-28 17:41:00 +0900", "snippet": "[BOJ] 백준 알고리즘 5430 AC아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 풀이구현은 생각보다 간단함하지만 시간복잡도를 최대한 줄여야 하는 문제라 줄일 부분을 최소한으로 만드는게 머리아팠다 ..​입력받은 p에서 ‘R’이 있으면 주어진 배열을 reverse, ‘D’가 있으면 첫번째 수를 버리는 것이다.이떄 ‘R’을 입력 받을 때 마다 reverse를 해주면 당연히 ~ 시간초과가 뜬다 ..​그래서 생각해 낸건 ‘R’을 입력 받을 때 마다 flag += 1을 해주고마지막에 출력 전에만 reverse를 진행해줬다.​그리고 ‘D’를 입력 받을 때도 생각을 해야하는데이전에 ‘R’ 입력이 있었으면 pop()으로 맨뒤에 숫자를 빼주고, ‘R’ 입력이 없었다면 popleft()로 첫번째 수를 버려준다.​마지막에 출력할 때는 flag % 2 == 0 조건을 걸어서 reverse 유무를 판단하고 출력해주면 됩니당 ~​from collections import dequeimport sysT = int(input())for _ in range(T): p = sys.stdin.readline().rstrip() n = int(input()) xn = deque(sys.stdin.readline().rstrip()[1:-1].split(&quot;,&quot;)) if n == 0 : xn = [] flag = 0 for i in p: if i == &#39;R&#39;: flag += 1 elif i == &#39;D&#39;: if len(xn) == 0 : print(&quot;error&quot;) break else: if flag % 2 == 0: xn.popleft() else: xn.pop() else: if flag % 2 == 1: xn.reverse() print(&quot;[&quot; + &quot;,&quot;.join(xn) + &quot;]&quot;)결과" }, { "title": "[Python] BOJ 2477 참외밭", "url": "/posts/BOJ2477/", "categories": "Study, BOJ", "tags": "python, algorithm, BOJ", "date": "2022-07-28 17:32:00 +0900", "snippet": "[BOJ] 백준 알고리즘 2477 참외밭아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 풀이기본적인 아이디어는 가장 큰 사각형에서 가장 작은 사각형의 넓이를 빼는 것 !작은 사각형의 넓이를 구하는게 관건인 문제였다.입력을 모두 받은 후에 가로방향에서 최장길이, 세로방향에서 최장길이를 찾아서 변수에 따로 저장해둔다.이 때, 그때의 인덱스 값을 저장해둬야 함 !​가로를 먼저 생각해봤을때, 인덱스가 1인 160이 최장길이로 나오는데이 때 인덱스 1을 기준으로 인덱스+1을 한 값은 30, 인덱스-1을 한 값은 50이다. 이를 빼서 절댓값을 취해주면 세로방향의 최단길이가 나온다.​세로도 똑같이 생각을 해보면 인덱스가 0인 50이 최장길이로 나오고,인덱스 0을 기준으로 인덱스+1을 한 값은 160, 인덱스-1을 한 값은 100이므로 이를 빼서 절댓값을 취해주면 가로방향의 최단길이인 60이 나온다​따라서 가로세로 방향의 최장길이의 곱과 최단길이의 곱을 뺀 후에 맨 처음 입력받은 k를 곱해주면 성공이다.k = int(input())arr = [list(map(int, input().split())) for _ in range(6)]min_w = min_h = max_w = max_h = 0maxw_idx = maxh_idx = 0for idx, tmp in enumerate(arr): if tmp[0] == 1 or tmp[0] == 2: if max_w &amp;lt; tmp[1]: maxw_idx = idx max_w = tmp[1] elif tmp[0] == 3 or tmp[0] == 4: if max_h &amp;lt; tmp[1]: maxh_idx = idx max_h = tmp[1]min_h = abs(arr[(maxw_idx - 1) % 6][1] - arr[(maxw_idx + 1) % 6][1])min_w = abs(arr[(maxh_idx - 1) % 6][1] - arr[(maxh_idx + 1) % 6][1])print (k * ((max_w * max_h) - (min_w * min_h)))​## 결과" }, { "title": "[Swift] 구조체와 클래스", "url": "/posts/swift-class/", "categories": "Programming, Swift", "tags": "swift, Xcode, Programming, iOS", "date": "2022-02-03 19:22:00 +0900", "snippet": " 본 게시물은 ‘스위프트 프로그래밍(3판)’의 9장 구조체와 클래스를 정리하며 작성하는 게시글입니다.아래 작성된 코드는 yagom님 swift 기본 문법의 코드를 참고했습니다.구조체1. 개념하나의 새로운 사용자 정의 데이터 타입이라고 말할 수 있다.2. 정의struct 키워드를 사용하여 정의할 수 있다. struct 구조체이름 { /* 프로퍼티와 메서드들 */ } // 구조체 예시 struct Student { var name: String var `class`: String // 키워드도 `로 묶어주면 사용 가능 }3. 구조체 인스턴스 생성 및 초기화구조체 정의 후에, 인스턴스를 생성하고 초기화하고자 할 때는 기본적으로 생성되는 멤버와이즈 이니셜라이저를 사용한다.인스턴스가 생성되고 초기화된 후 프로퍼티 값에 접근하고 싶다면 마침표(.)를 사용하면 된다.구조체를 상수 let으로 선언하면 인스턴스 내부 프로퍼티 값은 변경 불가능하고, 변수 var로 선언하면 값을 변경할 수 있다. // 프로퍼티 이름(name, age)으로 자동 생성된 이니셜라이저를 사용하여 구조체 생성 var gaaniiInfo: Student = Student(name: &quot;gaanii&quot;, class: &quot;swift&quot;) gaaniiInfo.class = &quot;ML/DL&quot; gaaniiInfo.name = &quot;galamgwi&quot;클래스1. 개념개념은 구조체와 동일하다. 다른 부분은 아래에서 설명 !2. 정의class 키워드를 사용하여 정의할 수 있다.클래스 정의 방법은 구조체와 매우 흡사하지만, 여기엔 가장 크게 다르다고 볼 수 있는 상속이 존재한다.클래스는 상속받을 수 있기 때문에 상속받을 때는 클래스 이름 뒤에 콜론(:)을 써주고 부모클래스 이름을 명시한다.(상속은 추후에 다룬다.)class 클래스 이름 { /* 프로퍼티와 메서드들 */}class 클래스 이름: 부모클래스 이름 { /* 프로퍼티와 메서드들 */}// 클래스 예시class Student { var name: String var `class`: String = &quot;Swift&quot;}3. 클래스 인스턴스의 생성 및 초기화" }, { "title": "[Python] BOJ 10989 수 정렬하기 3", "url": "/posts/BOJ10989/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-30 18:49:00 +0900", "snippet": "[BOJ] 백준 알고리즘 10989 수 정렬하기 3아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 풀이해당 문제는 메모리가 제한되어 있다.처음엔 퀵소트를 사용하여 코드를 작성했지만 메모리초과로 실패하였다 ..입력받은 값들을 계속 저장하여 메모리를 사용하는 것이 아니라,원래 만들어놓은 리스트를 이용하여 값을 정렬하고 카운팅할 수 있지 않을까 생각했다.코드는 다음과 같다.추가 ) input() 말고 sys.stdin.readline()을 사용해야 통과한 문제이다 ..두 개의 차이는 다음에 포스팅 할게용 :)import sysN = int(sys.stdin.readline())tmp = []nums = [0 for _ in range(10001)]for i in range(N): tmp = int(sys.stdin.readline()) nums[tmp] += 1for i in range(len(nums)): for j in range(nums[i]): print(i)결과" }, { "title": "[Python] BOJ 2751 수 정렬하기 2", "url": "/posts/BOJ2751/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-30 18:41:00 +0900", "snippet": "[BOJ] 백준 알고리즘 2751 수 정렬하기 2아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 풀이해당 문제는 시간 복잡도가 O(nlogn)인 알고리즘으로만 풀 수 있다.python에 내장되어 있는 sort는 O(nlogn)의 시간복잡도를 가지므로, 이전 문제의 첫 번째 풀이와 동일하다.N = int(input())nums = []for _ in range(N): nums.append(int(input()))nums.sort()for i in nums: print(i)결과" }, { "title": "[Python] BOJ 2750 수 정렬하기", "url": "/posts/BOJ2750/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-30 18:22:00 +0900", "snippet": "[BOJ] 백준 알고리즘 2750 수 정렬하기아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 풀이python으로 문제를 풀 때는 python에 내장된 sort를 이용 직접 sort를 구현2가지의 방법이 있다.첫 번째 코드는 내장된 sort를 사용한 것이다.N = int(input())nums = []for _ in range(N): nums.append(int(input()))nums.sort()for i in nums: print(i)두 번째 코드는 직접 sort를 구현한 것이다. (버블정렬)N = int(input())nums = []for _ in range(N) : nums.append(int(input())) for i in range(len(nums)) : for j in range(len(nums)) : if nums[i] &amp;lt; nums[j] : nums[i], nums[j] = nums[j], nums[i] for n in nums: print(n)결과" }, { "title": "[Python] BOJ 1002 터렛", "url": "/posts/BOJ1002/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-29 22:26:00 +0900", "snippet": "[BOJ] 백준 알고리즘 1002 터렛아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 이 문제는 점과 점 사이의 거리를 생각해보면 쉽게 풀 수 있는 문제이다.조건조건을 4가지 경우로 나누어 코드를 작성해야한다.아래 나오는 그림에서 빨간원의 반지름을 r1, 파란원의 반지름을 r2라고 하자.1. 두 원이 일치하는 경우이 경우, 두 원의 중점 좌표와 반지름의 길이가 동일해야한다.dis 변수를 통해 두 좌표 사이의 거리를 구해놓았고, 이 거리를 이용하여 조건문을 작성한다.두 원의 중점 좌표가 같다는 의미는 거리가 0이라는 의미이고, 반지름이 같다는 조건을 사용하면 된다.2. 두 원이 한 점에서 만나는 경우외접 또는 내접을 의미한다.내접의 경우, 두 좌표 사이의 거리인 dis와 r2를 더한 값이 r1이 된다. 이를 일반화하면 r1-r2의 절댓값이 dis가 된다는 것이다.외접의 경우, 각각의 반지름인 r1과 r2의 합이 두 좌표 사이의 거리인 dis가 되어야한다.3. 두 원이 두 점에서 만나는 경우이 경우는 두 좌표 사이의 거리인 dis가 각각의 반지름의 차와 합 사이에 있어야한다.4. 두 원이 만나지 않는 경우위 조건에서 가능한 모든 조건을 걸었으므로 else구문으로 처리해주면 된다. 조건문을 걸자면, 두 좌표 사이의 거리인 dis가 각각의 반지름의 합보다 커야한다. 코드구현은 다음과 같이 할 수 있다.import mathT = int(input())for i in range(T): x1, y1, r1, x2, y2, r2 = map(int, input().split()) dis = math.sqrt((x1-x2)**2 + (y1-y2)**2) # 두 원이 일치하는 경우 if dis == 0 and r1 == r2 : print(-1) # 두 원이 한 점에서 만나는 경우(외접 &amp;amp; 내접) elif abs(r1 - r2) == dis or r1 + r2 == dis : print(1) # 두 원이 두 점에서 만나는 경우 elif abs(r1 - r2) &amp;lt; dis &amp;lt; (r1 + r2) : print(2) # 두 원이 만나지 않는 경우 else : print(0)" }, { "title": "[Swift] 옵셔널 추출", "url": "/posts/swift-optional-unwrapping/", "categories": "Programming, Swift", "tags": "swift, Xcode, Programming, iOS", "date": "2022-01-28 18:51:00 +0900", "snippet": " 본 게시물은 ‘스위프트 프로그래밍(3판)’의 8장 옵셔널을 정리하며 작성하는 게시글입니다.아래 작성된 코드는 yagom님 swift 기본 문법의 코드를 참고했습니다.옵셔널 추출이란, 옵셔널에 들어있는 값을 사용하기 위해 꺼내오는 것 !1. 강제 추출 Forced Unwrapping옵셔널 강제 추출은 옵셔널의 값을 추출하는 가장 간단하지만 가장 위험한 방법이다.런타임 오류가 일어날 가능성이 가장 높고, 옵셔널을 만든 의미가 무색해지는 방법이기도 하기 때문이다.var myName: String? = &quot;gaanii&quot;var gaanii: String = myName!myName = nilgaanii = myName!if myName != nil { print(&quot;My name is \\(myName!)&quot;)} else { print(&quot;myName == nil&quot;)}옵셔널의 값을 강제 추출하려면 옵셔널 값의 뒤에 느낌표(!)를 붙여주면 값을 강제로 추출하여 반환하게 된다.만약 강제 추출 시 옵셔널에 값이 없다면, 즉 nil이라면 런타임 오류가 발생한다.런타임 오류의 가능성을 항상 내포하기 때문에 옵셔널 강제 추출 방식을 사용하는 것을 지양해야 한다.2. 옵셔널 바인딩 Optional Binding옵셔널 바인딩은 옵셔널에 값이 있는지 확인할 때 사용한다.만약 옵셔널에 값이 있다면 옵셔널에서 추출한 값을 일정 블록 안에서 사용할 수 있는 상수나 변수로 할당해서 옵셔널이 아닌 형태로 사용할 수 있도록 해준다.옵셔널 바인딩은 if - let 방식을 사용한다.1개의 옵셔널 값 추출var myName: String? = &quot;gaanii&quot;// 옵셔널 바인딩을 통하여 임시 상수를 할당한다.// 임시 상수는 if 구문을 실행하는 블록 안쪽에서만 사용할 수 있다. // 즉, if 블록 밖에서는 사용할 수 없고, else 블록에서도 사용할 수 없다.if let name = myName { print(&quot;My name is \\(name)&quot;)} else { print(&quot;myName == nil&quot;)}// my name is gaanii// 옵셔널 바인딩을 통하여 임시 변수를 할당한다.// 상수로 사용하지 않고 변수로 사용하고 싶다면 if var를 사용한다.if var name = myName { name = &quot;galamgwi&quot; print(&quot;My name is \\(name)&quot;)} else { print(&quot;myName == nil&quot;)}// my name is galamgwi여러 개의 옵셔널 값의 추출var myName: String? = &quot;gaanii&quot;var yourName: String? = nilif let name = myName, let friend = yourName { print(&quot;We are friend! \\(name) &amp;amp; \\(friend)&quot;)}yourName = &quot;Hwan&quot;if let name = myName, let friend = yourName { print(&quot;We are friend! \\(name) &amp;amp; \\(friend)&quot;)}// We are friend! gaanii &amp;amp; Hwan3. 암시적 추출 옵셔널 Implicitly Unwrapped Optionals사용 방법암시적 추출 옵셔널을 사용하려면 타입 뒤에 느낌표(!)를 사용하면 된다.사용 이유때때로 nil을 할당하고 싶지만, 옵셔널 바인딩으로 매번 값을 추출하기 귀찮거나 로직상으로 nil 때문에 런타임 오류가 발생하지 않을 것 같다는 확신이 들때 nil을 할당해줄 수 있는 옵셔널이 아닌 변수나 상수가 있으면 좋을 건데, 이때 사용하는 것이 암시적 추출 옵셔널이다.사용 예시var myName: String! = &quot;gaanii&quot;print(myName)myName = nil// 암시적 추출 옵셔널도 옵셔널이므로 바인딩 사용 가능 if let name = MyName { print(&quot;My name is \\(name)&quot;)} else { print(&quot;myName은 nil&quot;)}암시적 추출 옵셔널로 지정된 타입은 일반 값처럼 사용 가능하고, 옵셔널이기 때문에 nil도 할당 가능하다.하지만 nil이 할당되어 있을 때 접근을 시도하면 런타임 오류가 발생한다." }, { "title": "[Swift] 옵셔널", "url": "/posts/swift-optional/", "categories": "Programming, Swift", "tags": "swift, Xcode, Programming, iOS", "date": "2022-01-28 16:35:00 +0900", "snippet": " 본 게시물은 ‘스위프트 프로그래밍(3판)’의 8장 옵셔널을 정리하며 작성하는 게시글입니다.아래 작성된 코드는 yagom님 swift 기본 문법의 코드를 참고했습니다.옵셔널 개념단어 뜻 그대로 ‘선택적인’, 즉 값이 있을 수도, 없을 수도 있음을 나타내는 표현이다.이는 변수나 상수 등에 꼭 값이 있다는 것을 보장할 수 없다. 즉 변수 또는 상수의 값이 nil일 수도 있다’는 것을 의미한다.옵셔널 사용// var myName: Optional&amp;lt;String&amp;gt; 처럼 옵셔널을 명확히 써줄 수도 있다 // 하지만 물음표를 붙여주는 것이 조금 더 편하고 읽기 쉽기 때문에 굳이 긴 표현을 사용하지 않는다.var myName: String? = &quot;gaanii&quot;print(myName) // Optional(&quot;gaanii&quot;)myName = nilprint(myName) // nilnil은 옵셔널로 선언된 곳에서만 사용될 수 있다.옵셔널 변수 또는 상수 등은 데이터 타입 뒤에 물음표(?)를 붙여 표현한다.옵셔널 타입의 값을 print 함수를 통해 출력하면 Optional(“gaanii”) 라고 출력되지만, 앞으로는 주석 표현을 간단히 하기 위해 Optional()을 생략하고 표기할 것이다.옵셔널 사용 이유1. 명시적 표현 nil의 가능성을 코드만으로 표현이 가능하다. 문서/주석 작성 시간을 절약해준다.2. 안전한 사용 전달받은 값이 옵셔널이 아닌 경우, nil 체크를 하지 않고 사용 가능하다. 예외 상황을 최소화하는 안전한 코딩을 할 수 있다.옵셔널 정의열거형연관된 항목들을 묶어서 표현할 수 있는 타입을 말한다.이 자료형은 배열이나 딕셔너리 같은 타입과 다르게 프로그래머가 정의해준 항목 값 외에는 추가/수정이 불가하다.열거형 각 항목이 원시 값(Raw Value)이라는 형태로 (정수, 실수, 문자 타입 등의) 실제 값을 가질 수도 있다.옵셔널 정의public enum Optional&amp;lt;Wrapped&amp;gt; : ExpressibleByNilLiteral { case none case some(Wrapped) public init(_ some: Wrapped) // 중략 ...}let optionalValue: Optional&amp;lt;Int&amp;gt; = nillet optionalValue: Int? = nil위 코드에서 확인가능한 것은 다음과 같다. 옵셔널은 제네릭이 적용된 열거형이다. ExpressibleByNilLiteral 프로토콜을 따른다.(아직 배우지 않은 내용) 옵셔널이 값을 갖는 케이스와 그렇지 못한 케이스 두 가지로 정의되어 있다. 즉, nil일때는 none 케이스, 값이 있는 경우는 some 케이스(연관값 Wrapped)가 된다. 값이 옵셔널이라는 열거형의 방패막에 보호되어 래핑되어 있는 모습이다." }, { "title": "[Swift] 함수 고급", "url": "/posts/swift-function2/", "categories": "Programming, Swift", "tags": "swift, Xcode, Programming", "date": "2022-01-27 15:12:00 +0900", "snippet": " 본 게시물은 ‘스위프트 프로그래밍(3판)’의 7장 함수를 정리하며 작성하는 게시글입니다.아래 작성된 코드는 yagom님 swift 기본 문법의 코드를 참고했습니다.매개변수와 전달인자매개변수는 함수를 정의할 때 외부로부터 받아들이는 전달 값의 이름을 의미한다.전달인자(Argument), 혹은 인자는 함수를 실제로 호출할 때 전달하는 값을 의미한다. func hello(name: String) -&amp;gt; String { return &quot;Hello \\(name)!&quot; } let helloJenny: String = hello(name: Jenny) print(helloJenny) // Hello Jenny!위 코드에서 hello(name:)함수에서 매개변수는 name이고, 실제 사용 시 전달받는 값인 “Jenny”가 전달인자에 해당한다.매개변수 이름과 전달인자 레이블아래 코드를 살펴보자.func sayHello(myName: String, yourName: String) -&amp;gt; String { return &quot;Hello \\(yourName)! I&#39;m \\(myName)&quot;}print(sayHello(myName: &quot;gaanii&quot;, yourName: &quot;Hwan&quot;)) // Hello Hwan! I&#39;m gaanii위 코드에서 함수를 호출할 때 myName과 yourName이라는 매개변수 이름을 사용했다.여기서 매개변수 이름과 더불어 전달인자 레이블을 지정해줄 수 있다.전달인자 레이블은 함수 외부에서 매개변수의 역할을 좀 더 명확히 할 수 있다. 이를 사용하려면 함수 정의에서 매개변수 이름 앞에 한칸을 띄운 후 전달인자 레이블을 지정한다.func 함수이름(전달인자1 레이블 매개변수1 이름: 매개변수1 타입 ...) -&amp;gt; 반환타입 { /* 실행구문 */ return 반환 값}// from과 to라는 전달인자 레이블을 사용하며// myName과 name이라는 매개변수 이름이 있는 sayHello 함수 func sayHello(from myName: String, to name: String) -&amp;gt; String { return &quot;Hello \\(name)! I&#39;m \\(myName)&quot;}print(sayHello(from: &quot;gaanii&quot;, to: &quot;Hwan&quot;)) // Hello Hwan! I&#39;m gaanii함수 내부에서 전달인자 레이블을 사용할 수 없으며 함수를 호출할 때는 매개변수 이름을 사용할 수 없다.전달인자 레이블을 사용하고 싶지 않다면 와일드카드 식별자인 _를 사용하면 된다. 아래 코드에서 확인할 수 있다.func sayHello(_ name: String, _ times: Int) -&amp;gt; String { var result: String = &quot;&quot; for _ in 0 .. &amp;lt; times { result += &quot;Hello \\(name)!&quot; + &quot; &quot; } return result}print(sayHello(&quot;gaanii&quot;, 2)) // Hello gaanii! Hello gaanii!매개변수 기본값매개변수마다 기본값을 지정할 수 있다. 즉 매개변수가 전달되지 않으면 기본값을 사용한다는 것이다.매개변수 기본값이 있는 함수는 함수를 중복 정의한 것처럼 사용할 수 있다.func sayHello(_ name: String, _ times: Int = 3) -&amp;gt; String { var result: String = &quot;&quot; for _ in 0 .. &amp;lt; times { result += &quot;Hello \\(name)!&quot; + &quot; &quot; } return result}print(sayHello(&quot;Hwan&quot;))print(sayHello(&quot;gaanii&quot;, 2)) // Hello gaanii! Hello gaanii!sayHello(: times:) 함수의 times 매개변수에 기본값을 3으로 주면 times 매개변수를 넘겨주지 않아도 times 값을 3으로 설정해 함수가 동작한다.times 매개변수의 전달 값을 2로 설정하여 넘겨주면 전달 값을 반영하여 두 번 출력한다.가변 매개변수매개변수로 몇개의 값이 들어올지 모를 때, 가변 매개변수를 사용할 수 있다.가변 매개변수는 0개 이상(0개 포함)의 값을 받아올 수 있으며, 가변 매개변수로 들어온 값은 배열처럼 사용 가능하다.함수마다 가변 매개변수는 하나만 가질 수 있다.func sayHelloToFriends(me: String, friends names: String...) -&amp;gt; String { var result: String = &quot;&quot; for friend in names { result += &quot;Hello \\(friends)&quot; + &quot; &quot; } result += &quot;I&#39;m &quot; + me + &quot;!&quot; return result}print(sayHelloToFriends(me: &quot;gaanii&quot;, friends:&quot;Hwan&quot;, &quot;Stone&quot;, &quot;Hwi&quot;, &quot;Ko&quot;))// Hello Hwan! Hello Stone! Hello Hwi! Hello Ko! I&#39;m gaanii!prinnt(sayHelloToFriends(me: &quot;gaanii&quot;))// I&#39;m gaanii!함수의 전달인자로 값을 전달할 때는 보통 값을 복사해서 전달한다.값이 아닌 참조를 전달하려면 입출력 매개변수를 사용한다.입출력 매개변수의 전달 순서는 다음과 같다. 함수를 호출할 때, 전달인자의 값을 복사한다. 해당 전달인자의 값을 변경하면 1에서 복사한 것을 함수 내부에서 변경한다. 함수를 반환하는 시점에 2에서 변경된 값을 원래의 매개변수에 할당한다.참조는 inout 매개변수로 전달될 변수 또는 상수 앞에 앰퍼샌드(&amp;amp;)를 붙여 표현한다.아래 코드에서 값 타입 매개변수와 참조 타입 매개변수의 사용을 비교하여 볼 수 있다.var numbers: [Int] = [1, 2, 3]func nonReferenceParameter(_ arr: [Int]) { var copiedArr: [Int] = arr copiedArr[1] = 1}func referenceParameter(_ arr: inout [Int]) { arr[1] = 1}nonReferenceParameter(numbers)print(numbers[1]) // 2referenceParameter(&amp;amp;numbers) // 참조를 표현하기 위해 &amp;amp; 붙여줌 print(numbers[1]) // 1값 타입 데이터의 참조를 전달인자로 보내면 함수 내부에서 참조하여 원래 값을 변경한다(C 포인터와 유사)입출력 매개변수는 매개변수 기본값을 가질 수 없으며, 가변 매개변수로 사용될 수 없다.또한 상수는 변경될 수 없으므로 입출력 매개변수의 전달인자로 사용될 수 없다.데이터 타입으로서의 함수스위프트의 함수는 일급 객체이므로 하나의 데이터 타입으로 사용할 수 있다. 방법은 아래와 같다.(매개변수 타입의 나열) -&amp;gt; 반환타입함수타입의 사용예시를 확인해보자.typealias CalculateTwoInts = (Int, Int) -&amp;gt; Intfunc addTwoInts(_ a: Int, _ b: Int) -&amp;gt; Int { return a + b}func multiply TwoInts(_ a: Int, _ b: Int) -&amp;gt; Int { return a * b}// var mathFunction: (Int, Int) -&amp;gt; Int = addTwoInts와 동일한 표현var mathFunction: CalculateTwoInts = addTwoIntsprint(mathFunction(2, 5)) // 2 + 5 = 7mathFunction = multiplyTwoIntsprint(mathFunction(2, 5)) // 2 * 5 = 10함수의 타입 표현에서는 반환 타입을 생략할 수 없다.함수를 데이터타입으로 사용할 수 있다 것은 함수를 전달인자로 받을 수도, 반환 값으로 돌려줄 수도 있다는 의미이다.전달인자로 함수를 전달받는 함수func printMathResult(_ mathFunction: CalculateTwoInts, _ a: Int, _ b: Int) { print(&quot;Result: \\(mathFunction(a, b))&quot;)}printMathResult(addTwoInts, 3, 5) // Result: 8 반환 값으로 함수를 반환하는 함수func chooseMathFunction(_ toAdd: Bool) -&amp;gt; CalculateTwoInts { return toAdd ? addTwoInts : multiplyTwoInts}printMathResult(chooseMathFunction(true), 3, 5) // Result: 8 위 함수는 특정 조건에 따라 적절한 함수를 반환해주는 함수이다." }, { "title": "[Swift] 함수 기본", "url": "/posts/swift-function/", "categories": "Programming, Swift", "tags": "swift, Xcode, Programming", "date": "2022-01-27 13:48:00 +0900", "snippet": " 본 게시물은 ‘스위프트 프로그래밍(3판)’의 7장 함수를 정리하며 작성하는 게시글입니다. 글입니다.아래 작성된 코드는 yagom님 swift 기본 문법의 코드를 참고했습니다.함수와 메서드함수와 메소드는 기본적으로 동일한 개념을 가진다.상황, 위치에 따라 다른 용어로 부르는 것인데 다음과 같이 구분할 수 있다. 구조체, 클래스, 열거형 등 특정 타입에 연관되어 사용되는 함수를 메서드 모듈 전체에서 전역적으로 사용할 수 있는 함수를 그냥 함수함수 정의와 호출스위프트의 함수는 재정의(오버라이드)와 중복 정의(오버로드)를 모두 지원한다.따라서, 매개변수의 타입이 다르면 같은 이름의 함수를 여러개 만들 수 있고,매개변수의 개수가 달라도 같은 이름의 함수를 만들 수 있다.1. 함수 선언의 기본형태 func 함수이름(매개변수1 이름:매개변수1 타입, 매개변수2 이름:매개변수2 타입, ...) -&amp;gt; 반환타입 { /* 실행 구문 */ return 반환 값 } // 예시 func hello(name: String) -&amp;gt; String { return &quot;Hello \\(name)!&quot; } func introduce(name: String) -&amp;gt; String { // [return &quot;제 이름은 &quot; + name + &quot;입니다&quot;]와 같은 동작을 한다. &quot;제 이름은 &quot; + name + &quot;입니다&quot; } let helloJenny: String = hello(name: Jenny) print(helloJenny) // Hello Jenny! print(introduceJenny) // 제 이름은 Jenny입니다.기본적으로 함수의 이름과 매개변수(Parameter, 파라미터), 반환 타입(Return Type) 등을 사용하여 정의한다.함수를 정의하는 키워드는 func이고, 반환타입을 명시하기 전에 -&amp;gt;를 사용하여 어떤 타입이 반환될 것인지 명시해준다.introduce 함수와 같이 함수 내부의 코드가 단 한줄의 표현이고, 그 표현의 결괏값의 타입이 함수의 반환 타입과 일치한다면 return 키워드를 생략해도 그 표현의 결괏값이 함수의 반환값이 될 수 있다.2. 반환 값이 없는 함수 func 함수이름(매개변수1 이름 : 매개변수1 타입, 매개변수2 이름 : 매개변수2 타입, ...) -&amp;gt; Void { /* 실행 구문 */ return } // 예시 func printMyName(name: String) -&amp;gt; Void { print(name) } // 반환값이 없는 경우 반환 타입(Void) 생략 가능함 func printYourName(name: String) { print(name) }3. 매개변수가 없는 함수 func helloWorld() -&amp;gt; String { return &quot;Hello, World!&quot; } print(helloWorld()) // Hello, world!함수에 매개변수가 필요 없다면 매개변수 위치를 공란으로 비워둔다.4. 매개변수와 반환값이 모두 없는 함수 func 함수이름() -&amp;gt; Void { /* 함수 구현부 */ return } func hello() -&amp;gt; Void { print(&quot;hello&quot;) } func 함수이름(){ return } func bye(){ print(&quot;bye&quot;) }함수 구현이 짧은 경우는 가독성을 해치지 않는다면 줄바꿈을 하지 않고 한 줄에 표현해도 무관하다. 반환 값이 없는 경우, 반환 타입(Void)을 생략 가능하다." }, { "title": "[Python] BOJ 3053 택시 기하학", "url": "/posts/BOJ3053/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-26 23:21:00 +0900", "snippet": "[BOJ] 백준 알고리즘 3053 택시 기하학아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 이 문제는 유클리드 기하학에서의 원의 넓이와 문제에서 제시한 택시 기하학에서의 원의 넓이 구하는 것을 인지하는 문제이다.원은 어느 점에서의 거리가 일정한 점의 집합이다.택시 기하학에서의 두 점 T1(x1,y1), T2(x2,y2) 사이의 거리는 D(T1,T2) = |x1-x2| + |y1-y2| 으로 나타낼 수 있다.그림으로 보면 다음과 같다.따라서 원의 넓이는유클리드 기하학 → $\\pi \\times R^2 $비유클리드 기하학(택시 기하학) → $2 \\times R^2$해결 코드는 다음과 같다.from math import piR = int(input())print(&quot;%.6f&quot; % (pi * pow(R, 2)))print(&quot;%.6f&quot; % (2 * pow(R, 2)))" }, { "title": "[Python] BOJ 4153 직각삼각형", "url": "/posts/BOJ4153/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-26 23:03:00 +0900", "snippet": "[BOJ] 백준 알고리즘 4153 직각삼각형아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 이 문제는 피타고라스의 정리(Pythagorean theorem)를 사용한 문제이다.피타고라스의 정리는 직각삼각형의 빗변의 제곱이 두 직각변의 제곱의 합과 같다는 정리이다.입력받은 세 변의 길이를 a, b, c로 입력받고, a, b, c가 각각 빗변에 해당하는 경우를 조건문으로 확인해줬다.while True: a, b, c = map(int, input().split()) if a == b == c == 0: break if pow(a, 2) == pow(b, 2) + pow(c, 2) or pow(b, 2) == pow(a, 2) + pow(c, 2) or pow(c, 2) == pow(a, 2) + pow(b, 2): print(&quot;right&quot;) else: print(&quot;wrong&quot;)" }, { "title": "[Python] BOJ 3009 네 번째 점", "url": "/posts/BOJ3009/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-26 22:36:00 +0900", "snippet": "[BOJ] 백준 알고리즘 3009 네 번째 점아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 이 문제는 세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 문제이다.입력받은 좌표를 x, y로 입력받은 후, x좌표 끼리 y좌표 끼리 리스트에 추가한다.각 리스트에서 개수가 1개인 요소를 필요한 네 번째 점의 좌표로 출력해주면 된다.xPoint = []yPoint = []for i in range(3): x, y = list(map(int, input().split())) xPoint.append(x) yPoint.append(y)for i in range(3): if xPoint.count(xPoint[i]) == 1: x = xPoint[i] if yPoint.count(yPoint[i]) == 1: y = yPoint[i]print(x, y)" }, { "title": "[Python] BOJ 1085 직사각형에서 탈출", "url": "/posts/BOJ1085/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-26 22:14:00 +0900", "snippet": "[BOJ] 백준 알고리즘 1085 직사각형에서 탈출아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 왼쪽 아래 (0, 0)에 꼭짓점을 두고 오른쪽 위 꼭짓점을 (w, h)에 갖으며 각 변이 좌표축에 평행한 직사각형이 있고, (x, y) 좌표가 주어질 때 직사각형의 경계선까지 가는 거리의 최솟값을 구하는 문제이다.정말 간단한 문제다.주어진 좌표와 왼쪽 변 사이의 거리는 x주어진 좌표와 아래쪽 변 사이의 거리는 y주어진 좌표와 위쪽 변 사이의 거리는 h-y주어진 좌표와 오른쪽 변 사이의 거리는 w-x이다.위 네개의 거리 중 가장 짧은 거리를 출력해주면 된다.x, y, w, h = map(int, input().split())print(min(x, y, w-x, h-y))" }, { "title": "[Python] BOJ 9020 골드바흐의 추측", "url": "/posts/BOJ9020/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-26 20:42:00 +0900", "snippet": "[BOJ] 백준 알고리즘 9020 골드바흐의 추측아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 골드바흐의 추측은 유명한 정수론의 미해결 문제로 알려져있다.2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 추측인데 이러한 수를 골드바흐의 수라고 하고, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다.이 문제는 2보다 큰 짝수 n이 주어졌을때, n의 골드바흐 파티션을 출력하는 코드를 작성하는것이다.이 문제는 에라토스테네스의 체를 통해 소수 리스트를 먼저 구한다.이 후에 소수이면서, 두 수의 차가 가장 적으며, 두 수를 더했을 때 입력값을 만족시키는 두 수를 구하면 된다.두 수의 차가 가장 작은 경우를 구하는 게 이 문제의 핵심이다.두 수를 a, b라고 했을 때, 두 수를 입력값인 n의 절반 값인 n/2로 두고 하나는 증가, 하나는 감소시키면서 소수임을 체크한다. 둘 다 소수일 때 출력한다.아래 코드에서는 a는 감소, b는 증가하여 출력한다.def prime_list(): # 에라토스테네스의 체로 소수 리스트 구하기 n = 10001 # 문제에서 제시한 조건 sieve = [True] * n for i in range(2, int(n ** 0.5)+1): if sieve[i]: for j in range(i+i, n, i): sieve[j] = False return [i for i in range(2, n) if sieve[i] == True]T = int(input())Prime = prime_list()for i in range(T): n = int(input()) a = n // 2 b = n // 2 while True: if a and b in Prime: print(a, b) break else: a -= 1 b += 1" }, { "title": "[Python] BOJ 4948 베르트랑 공준", "url": "/posts/BOJ4948/", "categories": "Study, BOJ", "tags": "python, algorithm, prime number, BOJ", "date": "2022-01-26 19:11:00 +0900", "snippet": "[BOJ] 백준 알고리즘 4948 베르트랑 공준아래 백준 로고를 클릭하면 해당 문제로 이동합니다 😀 이 문제는 자연수 n이 주어졌을 때, n보다 크고 2n보다 작거나 같은 소수의 개수를 구하는 코드를 작성하는 문제이다.처음에 문제를 푼 코드는 다음과 같다.이 코드는 무작정 모든 구간을 반복하기때문에 .. 시간초과가 떴다.import mathn = int(input())while n != 0: array = [True for _ in range(2 * n + 1)] for i in range(2, int(math.sqrt(2 * n)) + 1): if array[i]: j = 2 while i * j &amp;lt;= 2 * n: array[i * j] = False j += 1 count = 0 for i in range(n + 1, 2 * n + 1): if array[i]: count += 1 print(count) n = int(input())그래서 이전 블로그 포스팅 글과 같이 에라토스테네스의 체를 이용하여 코드를 작성했다.문제에서 최대 n의 값을 123456이라고 정해줬으므로, 최대 소수를 모두 구해놓은 후 n+1 &amp;lt;= x &amp;lt;= 2n 범위 내에서 소수의 개수를 세줬다.N = 123456 * 2 + 1sieve = [True] * Nfor i in range(2, int(N ** 0.5) + 1): if sieve[i]: for j in range(i + i, N, i): sieve[j] = Falsedef prime_cnt(val): cnt = 0 for i in range(val + 1, val * 2 + 1): if sieve[i]: cnt += 1 print(cnt)while True: val = int(input()) if val == 0: break prime_cnt(val)" }, { "title": "[Algorithm] 에라토스테네스의 체", "url": "/posts/eratosthenes/", "categories": "Study, Algorithm", "tags": "python, algorithm, prime number", "date": "2022-01-26 18:05:00 +0900", "snippet": "에라토스테네스의 체 Sieve of Eratosthenes소수1과 자기 자신 이외의 자연수로는 나눌 수 없는 자연수소수 판별 알고리즘을 단순하게 생각해보면아래 코드는 1부터 100 사이의 소수를 판별하는 파이썬 코드이다.n = 100def isPrime(n): if n &amp;lt; 2: return False for i in range(2, n): if n % i == 0: return False return Truefor i in range(n+1): if(isPrime(i)): print(i)에라토스테네스의 체위 코드는 brute force의 방식이라고 볼 수 있다.한 개의 소수를 구할 때는 꽤 괜찮은 방법이라고 볼 수 있지만, N부터 M까지 범위의 모든 소수를 구할 때는 효율적인 방법이 아니다.그래서 주어진 범위 내에서 소수를 구할 때 사용하는 것이 에라토스테네스의 체이다.이 방법은 주어진 범위에서 합성수를 지우는 방식으로 소수를 조금 더 빠르게 찾는 방법이다.위 알고리즘은 다음 과정을 통해 진행된다. 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 위 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다. 2는 소수이므로 오른쪽에 2를 쓴다.(빨간색) 자기 자신을 제외한 2의 배수를 모두 지운다. 남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다.(초록색) 자기 자신을 제외한 3의 배수를 모두 지운다. 남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다.(파란색) 자기 자신을 제외한 5의 배수를 모두 지운다. 위 과정을 반복하면 구하는 구간의 모든 소수가 남는다.위 알고리즘을 파이썬으로 구현하면 다음과 같다.def prime_list(n): # 에라토스테네스의 체 리스트를 초기화: n개의 요소를 우선 True로 설정한다(소수로 간주) sieve = [True] * n # n의 최대 약수는 sqrt(n) 이하이므로 i = sqrt(n)까지 for문으로 확인한다. for i in range(2, int(n ** 0.5)): if sieve[i] == True: # i가 소수인 경우 for j in range(i+i, n, i): # 자기 자신을 제외한 i의 배수를 모두 False로 설정 sieve[j] = False # sieve에서 True인 값만 list형식으로 리턴 return [i for i in range(2, n) if sieve[i] == True]" }, { "title": "[Swift] 데이터 타입 고급", "url": "/posts/swift-datatype2/", "categories": "Programming, Swift", "tags": "swift, Xcode, Programming", "date": "2022-01-12 21:34:00 +0900", "snippet": " 본 게시물은 ‘스위프트 프로그래밍(3판)’의 4장 데이터 타입 고급을 정리하며 작성하는 게시글입니다.아래 작성된 코드는 yagom님 swift 기본 문법의 코드를 참고했습니다.타입 별칭스위프트에서 기본으로 제공하는 데이터 타입이든, 사용자가 임의로 만든 데이터 타입이든 이미 존재하는 데이터 타입의 임의로 다른 이름(별칭)을 부여할 수 있다. 그런 다음 기본 타입 이름과 이후에 추가한 별칭을 모두 사용할 수 있다. » C언어 구조체에서의 typedef를 생각하면 될 것 같다.typealias MyInt = Inttypealias YourInt = Inttypealias MyDouble = Doublelet age: MyInt = 11var year: YourInt = 2000// MyInt도, YourInt도 이름은 다르지만 사실 같은 Int이기 때문에 같은 타입으로 취급year = agelet month: Int = 8 // 기존의 타입 이름도 사용 가능 let percentage: MyDouble = 99.9 // Int 외에 다른 자료형도 모두 별칭 사용 가능 튜플 Tuple프로그래머 마음대로 만드는 타입으로 지정된 데이터의 묶음이라고 표현할 수 있다.C언어에서 원시 구조체의 형태와 가깝고, Python의 튜플과 유사하다.튜플은 타입 이름이 따로 존재하지 않는다. 일정 타입의 나열만으로 튜플 타입을 생성해줄 수 있다.// String, Int, Double 타입을 갖는 튜플 var person: (String, Int, Double) = (&quot;gaanii&quot;, 23, 166.8)// 인덱스를 통해 값을 빼 올 수 있다.print(&quot;이름: \\(person.0), 나이: \\(person.1), 신장: \\(person.2))// 인덱스를 통해 값을 할당할 수도 있다. person.1 = 100person.2 = 180.2위 코드에서는 튜플의 각 요소를 이름 대신 숫자로 표현하기 때문에 간편해 보일 수 있지만, 차후 타인이 코드를 볼 때 각 요소가 어떤 의미가 있는지 인지하기 어렵기 때문에 아래 코드와 같이 튜플의 요소마다 이름을 붙여주는것이 좋다.// String, Int, Double 타입을 갖는 튜플 var person: (name: String, age: Int, height: Double) = (&quot;gaanii&quot;, 23, 166.8)// 요소 이름을 통해 값을 빼 올 수 있다.print(&quot;이름: \\(person.name), 나이: \\(person.age), 신장: \\(person.height)&quot;)// 요소 이름을 통해 값을 할당할 수도 있으며, 인덱스를 통해서도 가능하다.person.age = 99person.2 = 180.2또, 튜플에는 타입 이름에 해당하는 키워드가 없어 불편함을 겪을 수 있는데, 이때 타입 별칭을 사용하여 조금 더 깔끔하고 안전하게 코드를 작성할 수 있다. 아래 코드를 참고하자.typealias PersonTuple = (name: String, age: Int, height: Double)let gaanii: PersonTuple = (&quot;gaanii&quot;, 23, 166.8)let mrstone: PersonTuple = (&quot;stone&quot;, 26, 167.1)컬렉션형스위프트는 튜플 외에도 많은 수의 데이터를 묶어서 저장하고 관리할 수 있는 컬렉션 타입을 제공한다. 컬렉션 타입에는 배열 Array, 딕셔너리 Dictionary, 세트 Set 등이 있다.let 키워드를 사용해 상수로 선언하면 변경 불가능, var 키워드를 사용해 변수로 선언하면 변경 가능을 의미한다. 배열 Array같은 타입의 데이터를 일렬로 나열한 후 순서대로 저장하는 형태의 컬렉션 타입이다.각기 다른 위치에 같은 값이 들어갈 수 있다. 실제로 배열을 사용할 때는 Array 키워드와 타입 이름의 조합으로 사용 대괄호로 값을 묶어 Array 타입임을 표현 빈 배열은 이니셜라이저 또는 리터럴 문법을 통해 생성 // 빈 Int Array 생성 var integers: Array&amp;lt;Int&amp;gt; = Array&amp;lt;Int&amp;gt;() // 같은 표현 var integers: Array&amp;lt;Int&amp;gt; = [Int]() var integers: Array&amp;lt;Int&amp;gt; = [] var integers: [Int] = Array&amp;lt;Int&amp;gt;() var integers: [Int] = [Int]() var integers: [Int] = [] var integers = [Int]() isEmpty 프로퍼티로 비어있는 배열인지 확인 가능하다. count 프로퍼티로 배열에 몇 개의 요소가 존재하는지 알 수 있다. 배열의 각 요소에 인덱스를 통해 접근할 수 있으며, 인덱스는 0부터 시작한다. 잘못된 인덱스로 접근하려고 하면 익셉션 오류 Exception Error가 발생한다. 맨 처음과 맨 마지막 요소는 first와 last 프로퍼티를 통해 가져올 수 있다. firstIndex(of:) 메소드를 이용하면 해당 요소의 인덱스를 알아낼 수 있다. 이 메소드의 경우 중복된 요소가 있다면 제일 먼저 발견된 요소의 인덱스를 반환한다. 맨 뒤에 요소를 추가하고 싶다면 append(-:) 메소드를 사용한다. 중간에 요소를 삽입하고 싶다면 insert(_:at:) 메소드를 사용한다. 요소를 삭제하고 싶다면 remove(_:) 메소드를 사용하고, 메소드를 사용하면 해당 요소가 삭제된 후 반환된다. 딕셔너리 Dictionary요소들이 순서 없이 키와 값의 쌍으로 구성되는 컬렉션 타입이다.딕셔너리 안에는 키가 하나이거나 여러 개일 수 있지만, 하나의 딕셔너리 안의 키는 같은 이름을 중복해서 사용할 수 없다. 딕셔너리는 Dictionary 키워드와 키의 타입, 값의 타입 이름의 조합으로 써준다.대괄호로 키와 값의 타입 이름의 쌍을 묶어 딕셔너리 타입임을 표현한다. // Key가 String 타입이고 Value가 Any인 빈 Dictionary 생성 var anyDictionary: Dictionary&amp;lt;String, Any&amp;gt; = [String: Any]() // 같은 표현 var anyDictionary: Dictionary &amp;lt;String, Any&amp;gt; = Dictionary&amp;lt;String, Any&amp;gt;() var anyDictionary: Dictionary &amp;lt;String, Any&amp;gt; = [:] var anyDictionary: [String: Any] = Dictionary&amp;lt;String, Any&amp;gt;() var anyDictionary: [String: Any] = [String: Any]() var anyDictionary: [String: Any] = [:] var anyDictionary = [String: Any]() 딕셔너리는 각 값에 키로 접근할 수 있는데, 딕셔너리 내부에서 키는 유일해야 하며, 값은 유일하지 않다. 딕셔너리는 배열과 다르게 딕셔너리 내부에 없는 키로 접근해도 오류가 발생하지 않고, 이 경우 nil을 반환한다. 특정 키에 해당하는 값을 제거하려면 `removeValue(forKey:) 메소드를 사용한다. // 키에 해당하는 값 할당 anyDictionary[&quot;someKey&quot;] = &quot;value&quot; anyDictionary[&quot;anotherKey&quot;] = 100 print(anyDictionary) // [&quot;someKey&quot;: &quot;value&quot;, &quot;anotherKey&quot;: 100] // 키에 해당하는 값 변경 anyDictionary[&quot;someKey&quot;] = &quot;dictionary&quot; print(anyDictionary) // [&quot;someKey&quot;: &quot;dictionary&quot;, &quot;anotherKey&quot;: 100] // 키에 해당하는 값 제거 anyDictionary.removeValue(forKey: &quot;anotherKey&quot;) anyDictionary[&quot;someKey&quot;] = nil print(anyDictionary) // [:] 세트 Set 같은 타입의 데이터를 순서 없이 하나의 묶음으로 저장하는 형태의 컬렉션 타입이다. 세트 내의 값은 모두 유일한 값, 즉 중복된 값이 존재하지 않기 때문에, 순서가 중요하지 않거나 각 요소가 유일한 값이어야 하는 경우에 사용한다. 세트는 Set 키워드와 타입 이름의 조합으로 써준다. 배열과 마찬가지로 대괄호로 값들을 묶어 세트 타입임을 표현하지만, 배열과 달리 축약형(Array를 [Int]로 축약하는 것과 같은)이 없다. // 빈 Int Set 생성 var integerSet: Set&amp;lt;Int&amp;gt; = Set&amp;lt;Int&amp;gt;() integerSet.insert(1) integerSet.insert(100) integerSet.insert(99) integerSet.insert(99) integerSet.insert(99) print(integerSet) // [100, 99, 1] print(integerSet.contains(1)) // true print(integerSet.contains(2)) // false integerSet.remove(100) integerSet.removeFirst() print(integerSet.count) // 1 세트는 자신 내부의 값들이 모두 유일함을 보장하므로, 집합관계를 표현하고자 할 때 유용하게 쓰일 수 있다. 아래 코드는 세트를 활용한 집합 연산을 보여준다. // Set는 집합 연산에 꽤 유용합니다 let setA: Set&amp;lt;Int&amp;gt; = [1, 2, 3, 4, 5] let setB: Set&amp;lt;Int&amp;gt; = [3, 4, 5, 6, 7] // 합집합 let union: Set&amp;lt;Int&amp;gt; = setA.union(setB) print(union) // [2, 4, 5, 6, 7, 3, 1] // 합집합 오름차순 정렬 let sortedUnion: [Int] = union.sorted() print(sortedUnion) // [1, 2, 3, 4, 5, 6, 7] // 교집합 let intersection: Set&amp;lt;Int&amp;gt; = setA.intersection(setB) print(intersection) // [5, 3, 4] // 차집합 let subtracting: Set&amp;lt;Int&amp;gt; = setA.subtracting(setB) print(subtracting) // [2, 1] " }, { "title": "[Swift] 데이터 타입 기본", "url": "/posts/swift-datatype/", "categories": "Programming, Swift", "tags": "swift, Xcode, Programming", "date": "2022-01-12 20:34:00 +0900", "snippet": " 본 게시물은 ‘스위프트 프로그래밍(3판)’의 3장 데이터 타입 기본을 정리하며 작성하는 게시글입니다.아래 작성된 코드는 yagom님 swift 기본 문법의 코드를 참고했습니다. 데이터 타입(자료형)이란 프로그램 내에서 다뤄지는 데이터의 종류를 의미합니다. 스위프트의 기본 데이터 타입은 구조체를 타입의 기반으로 삼아 스위프트의 다양한 기능(익스텐션, 제네릭 등)을 두루 사용하여 구현되어 있습니다. 스위프트의 모든 데이터 타입의 이름은 첫 글자가 대문자로 시작하는 대문자 카멜케이스를 사용합니다. Int &amp;amp; UInt정수 타입을 의미한다. (현재는 기본적으로 Int는 64비트 정수형, UInt는 64비트 양의 정수형)Int는 +, -. 즉 부호가 있는 정수를 뜻하며, 이 중 - 부호를 포함하지 않는 0을 포함한 양의 정수는 UInt로 표현한다.각각 데이터 타입의 최댓값/최솟값은 max와 min 프로퍼티로 알아볼 수 있다.var someInt:Int = -100// someInt = -100.1 // 컴파일 오류 발생, 자료형이 다르다.var someUInt:UInt = 100// someUInt = -100 // 컴파일 오류 발생, UInt에 음수를 넣을 수 없다.// someUInt = someInt // 컴파일 오류 발생, Int와 UInt의 자료형은 엄연히 다르다.Bool불리언 타입을 의미한다.불리언 타입은 참(true) 또는 거짓(false)만 값으로 가진다.var someBool: Bool = truesomeBool = false// someBool = 0 // 컴파일 오류 발생// someBool = 1 // 컴파일 오류 발생Float &amp;amp; Double부동소수점을 사용하는 실수며 부동소수 타입이라고 한다. 흔히 말하는 소수점 자리가 있는 수를 말한다.부동소수 타입은 정수 타입보다 훨씬 넓은 범위의 수를 표현할 수 있고, 스위프트에는 64비트의 부동소수를 표현하는 Double와 32비트의 부동소수를 표현하는 Float가 있다.64비트 환경에서는 Double은 최소 15자리의 십진수를 표헌할 수 있는 반면에, Floatsms 6자리의 숫자까지만 표현이 가능하다. 필요에 따라 둘 중하나를 선택하여 사용하면 되는데, 대부분은 Double을 사용하길 권장한다.var someFloat:Float = 3.14somefloat = 3var someDouble:Double = 3.14someDouble = 3// someDouble = someFloat // 컴파일 오류 발생 스위프트 4.2 버전부터 임의의 수를 만드는 random(in: ) 메소드가 추가되었다.정수(Int, UInt), 실수(Float, Double) 모두 임의의 수를 만들 수 있다.Character말 그대로 문자를 의미한다. 단어, 문장과 같은 문자의 집합이 아닌 단 하나의 문자를 의미한다. 스위프트는 유니코드 9 문자를 사용하기때문에 영어는 물론, 유니코드에서 지원하는 모든 언어 및 특수기호 등을 사용할 수 있다.(심지어, 스위프트 코드를 작성할 때도 유니코드 문자를 모두 사용할 수 있다.)var someCharacter:Character = &quot;🇰🇷&quot;someCharacter = &quot;😄&quot;someCharacter = &quot;가&quot;someCharacter = &quot;A&quot;// someCharacter = &quot;하하하&quot; // 컴파일 오류발생, Character는 단 하나의 문자만을 의미하기 때문이다.String문자의 나열, 즉 문자열을 의미한다.Character와 마찬가지로 유니코드를 사용하고, 값의 앞뒤에 큰따옴표(““)를 사용하여 표현한다.var someString: String = &quot;하하하 😄 &quot;someString = someString + &quot;웃으면 복이와요&quot;print(someString) // 하하하 😄 웃으면 복이와요// someString = someCharacter // 컴파일 오류발생, Character와 String은 다른 데이터 타입이다.여러줄을 가지는 문자열을 사용하고싶다면 큰따옴표 세 개를 사용하면 된다.반드시 겹따옴표 세 개인 줄(첫줄과 끝줄)에서 줄 바꿈을 하지 않으면 오류가 발생한다.someString = &quot;&quot;&quot;안녕하세요저는 개발자가 되고싶은가람쥐입니다!&quot;&quot;&quot;// 아래와 같은 경우 오류가 발생한다.someString = &quot;&quot;&quot;오류발생&quot;&quot;&quot;스위프트에는 문자열 내에서 일정 기능을 하는 특수문자(제어문자)가 존재한다.모두 백슬래시에 특정한 문자를 조합하여 사용하며, 가장 많이 쓰이는 특수문자는 아래 표와 같다. 특수문자 설명 \\n 줄바꿈 문자 \\\\ 문자열 내에서 백슬래시를 표현하고자 할 때 사용 \\&quot; 문자열 내에서 큰따옴표를 표현하고자 할 때 사용 \\t 탭 문자. 키보드의 탭키를 눌렀을 때와 같은 효과 \\0 문자열이 끝났음을 알리는 null 문자 Any, AnyObject, nilAny는 모든 데이터 타입을 사용할 수 있다는 뜻이다.변수 또는 상수의 데이터 타입이 Any로 지정되어있다면 그 변수 또는 상수에는 어떤 종류의 데이터 타입이든지 상관없이 할당 가능하다.AnyObject는 Any보다 조금 한정된 의미를 가지며, 클래스의 인스턴스만 할당할 수 있다. 이 내용은 추후 업로드할 게시물에서 설명하겠다.var someVar: Any = &quot;gaanii&quot; // Any로 선언된 변수에는 문자열도someVar = 23 // 정수도someVar = 166.9 // 실수, 또는 어떤 타입의 값도 할당 가능class SomeClass {}var someAnyObject: AnyObject = SomeClass()someAnyObject = 123.12 // 컴파일 오류발생, 클래스의 인스턴스가 아니기 때문 하지만 Any와 AnyObject는 되도록 사용하지 않는 편이 좋다.타입에 엄격한 스위프트의 특성 상 위와 같은 데이터 타입으로 선언된 변수의 값을 가져다 쓰려면 매번 타입 확인 및 변환을 해줘야 하는 불편함이 존재하며, 예기치 못한 오류의 위험을 증가시킨다.nil은 특정 타입이 아니라 없음을 의미하는 스위프트의 키워드이다.즉, 변수 또는 상수에 값이 들어있지 않고 비어있음을 의미하고, 다른 언어에서의 ‘NULL’, ‘Null’&amp;lt; ‘null’ 등과 유사한 표현이다.nil을 다루는 방법은 추후 업로드 할 옵셔널 파트에서 다루게 된다." }, { "title": "[전자계산기구조] Computer Architecture TA_Week10", "url": "/posts/TA-week10/", "categories": "INU, Computer Architecture", "tags": "ComputerArchitecture, INU, TA", "date": "2021-05-06 19:00:00 +0900", "snippet": "기말고사 대비 개념정리본 내용은 간단하고 빠르게 개념을 정리하기 위함으로, 모든 시험범위를 담고있지 않습니다.📌 set on less than : sltslt $t0, $s0, $s1 # if $s0 &amp;lt; $s1 # then $t0 = 1 # else $t0 = 0 두 변수 간의 대소 비교가 필요할 때 사용되는 명령어 → 두 개의 근원지 레지스터의 값을 비교한 후 목적지 레지스터 값을 설정하는 명령어 → 첫 번째 근원지 레지스터의 값 &amp;lt; 두 번째 근원지 레지스터의 값 : 목적지 레지스터 값은 1 → 첫 번째 근원지 레지스터의 값 &amp;gt; 두 번째 근원지 레지스터의 값 : 목적지 레지스터 값은 0 → slt는 R type을 사용, opcode → 0, funct → 42📌 set on less than immediate : sltislti $t0, $s0, 10 # if $s0 &amp;lt; 10 # then $t0 = 1 # else $t0 = 0 slt와 유사하게 레지스터와 특정 상수와의 대소 비교가 필요할 때 사용되는 명령어 → slti는 I type을 사용, opcode → a (hex), 10 (decimal)📌 Other Branch Instructionsslt, slti, beq, bne와 $zero를 사용하여 모든 비교조건을 만들 수 있다.blt $s1, $s2, Lb1 # less thanble $s1, $s2, Lb1 # less than or equal tobgt $s1, $s2, Lb1 # greater thanbge $s1, $s2, Lb1 # great than or equal to실제 존재하는 명령이 아니고, 앞에 소개된 명령어들을 통해 만들어낼 수 있다.📌 Another Instruction for Changing Flow보통의 프로그래밍 언어에서 switch~case 문을 구현하는 방법은 if-then-else의 연속으로 바꾸는것이다.jr $t1 # go to address in $t1 jr ( jump register ) 는 레지스터에 명시된 주소로 무조건 점프하는 것을 의미함. jr은 R type 사용, opcode → 0, funct → 8 Compiling a Case(Switch) Statement📌 MIPS Data Types Bit : 0, 1 Bit String : 특정 길이의 bits sequence → 8bits : byte → 16bits : half-word → 32bits : word Character : ASCII 7 bit code Decimal : digits 0-9 Integer : 2’s complement Floating Point📌 Byte Addresses프로그램에서 8bits로 구성된 byte를 많이 사용하므로 대부분의 컴퓨터는 byte 단위로 주소를 지정한다.따라서, word의 memory address는 4의 배수여야함. ( → 정렬 제약, alignment restriction ) Big Endian 제일 왼쪽 ( 최상위 byte address ) 를 word address로 사용함. highest memory location을 LSB에 저장함. → 0 x C2 01 00 00 = $2^{31} + 2^{30} + 2^{25} + 2^{16}$ = 3,254,845,440 Little Endian 제일 오른쪽 ( 최하위 byte address ) 를 word address로 사용함. lowest memory location을 LSB에 저장함. → 0 x 00 00 01 C2 = $2^8 + 2^7 + 2^6 + 2$ = 450 📌 Loading and Storing Byteslb $t0, 2($s3) # load byte from memorylbu $t0, 2($s3) # load byte unsigned from memorysb $t0, 6($s3) # store byte to memory lb ( Load Byte ) : opcode → 20 (hex), 32 (decimal) lbu ( Load Byte Unsigned ) : opcode → 24 (hex), 36 (decimal) sb ( Store Byte ) : opcode → 28 (hex), 40 (decimal)📌 Loading and Storing Half Wordslh $t0, 2($s3) # load half word from memorysh $t0, 6($s3) # store half word to memory lh ( Load Half ) : opcode → 21 (hex), 33 (decimal) sh ( Store Half ) : opcode → 29 (hex), 41 (decimal)📌 Shift Operationssll $t2, $s0, 8 # $t2 = $s0 &amp;lt;&amp;lt; 8 bitssrl $t2, $s0, 8 # $t2 = $s0 &amp;gt;&amp;gt; 8 bits sll ( Shift Left Logical ) : opcode, funct → 0 srl ( Shift Right Logical ) : opcode → 0, funct → 2📌 More Shift Operationssra $t2, $s0, 8 # $t2 = $s0 &amp;gt;&amp;gt; 8 bits sra ( Shift Right Arithmetic ) : opcode → 0, funct → 3 → 이동된 값의 산술적 정확성을 유지함 ( 즉, 오른쪽으로 1 bit shift 된 숫자는 원래 값의 1/2 배여야 하며, 왼쪽으로 1 bit shift 된 숫자는 원래 값의 2배여야 함.📌 Logical Operationsand $t0, $t1, $t2 # $t0 = $t1 &amp;amp; $t2or $t0, $t1, $t2 # $t0 = $t1 | $t2nor $t0, $t1, $t2 # $t0 = not($t1 | $t2)andi $t0, $t1, 0xff00 # $t0 = $t1 &amp;amp; ff00ori $t0, $t1, 0xff00 # $t0 = $t1 | ff00📌 Larger Constantslui $t0, 0xaaaaori $t0, $t0, 0xaaaa lui ( Load Upper Immediate ) : register의 상위 16비트에 상수를 넣는 명령어 → lui 명령 후 ori를 통해 하위 16비트를 더해준다" }, { "title": "[전자계산기구조] Computer Architecture TA_Week7", "url": "/posts/TA-week7/", "categories": "INU, Computer Architecture", "tags": "ComputerArchitecture, INU, TA", "date": "2021-04-15 10:00:00 +0900", "snippet": "중간고사 대비 개념 정리본 내용은 간단하고 빠르게 개념을 정리하기 위함으로, 모든 시험범위를 담고있지 않습니다.📌 Negative Numbers Signed Magnitude Most Significant Bit(MSB)는 sign bit로 사용된다. → 0은 positive, 1은 negative 0을 표현하는 방법이 2가지 존재한다. → +0은 0000, -0은 1000 -7 ~ +7까지 15개의 숫자만 표현 가능하다. Signed-1’s complement 2 - 1 - N으로 정의된다. Arithmetic works 6 — 1 = 6 + ( -1 ) = 0110 + 1110 = (1)0100 + “1” = 0101(5) 끝자리 올림(end carry)가 발생할 경우, 연산 결과에 1을 더해 real answer을 도출한다. 여기서 더해진 “1”을 순환 자리 올림(end around carry)라고 한다. 여전히 0을 표현하는 방법은 2가지이다. Signed-2’s complement 2 - N으로 정의되며, 1’s complement에 1을 더한 값과 같다. 부호화 2의 보수에서는 0이 1개만 존재한다. -8 부터 +7 까지 16개의 숫자를 표현 가능하다. 📌 IEEE 754 Standard Sign(부호) : 1 bit Fraction(소수) : 23 bits Exponent(지수) : 8 bits -&amp;gt; Exponent에서는 Biased Notation 사용 -&amp;gt; bias는 127이다.📌 Floating Point Addition F1, F2의 hidden bit 복구 작은 지수를 가자는 수의 소수점 정렬 유효자리 덧셈 덧셈 결과 Normalize Normalize된 값을 rounding(자리 맞춤) Bit hidden시켜서 저장📌 Instruction Format op : 명령어가 실행 할 연산의 종류 -&amp;gt; 연산자(opcode)라고 부름 rs : 첫 번째 근원지(source) 피연산자 레지스터 rt : 두 번째 근원지 피연산자 레지스터 rd : 목적지 (destination) 레지스터. 연산의 결과를 저장 shamt : 자리 이동량(shift amount) funct : 기능 (function). op필드에서 연산의 종류를 표시하고, funct 필드에서 그 중의 한 연산을 구체적으로 지정 immediate : 상수 또는 주소 jump target : 이동 할 목적지의 주소📌 MIPS Instruction Arithmetic add add $s1, $s2, $s3 Instruction Format : R Opcode &amp;amp; Function : 0 &amp;amp; 32 subtract sub $s1, $s2, $s3 Instruction Format : R Opcode &amp;amp; Function : 0 &amp;amp; 34 add immediate addi $s3, $s3, 4 Instruction Format : I Opcode : 8 Data Transfer load lw $t0, 24($s2) Instruction Format : I Opcode : 35 store sw $t0, 24($s2) Instruction Format : I Opcode : 43 Conditional branch beq(branch if equal) beq $s1, $s2, Lb1 Instruction Format : I Opcode : 4 bne(branch if not equal) bne $s1, $s2, Lb1 Instruction Format : I Opcode : 5 Unconditional jump jump j Lb1 Instruction Format : J Opcode : 2 📌 Naming Conventions for Register" }, { "title": "[전자계산기구조] Computer Architecture TA_Week6", "url": "/posts/TA-week6/", "categories": "INU, Computer Architecture", "tags": "ComputerArchitecture, INU, TA", "date": "2021-04-08 12:50:00 +0900", "snippet": "전자계산기구조TA_Week6📌 Registers vs. Memory Register는 memory보다 더 빠르게 접근 가능함 memory data에서 동작하려면 load, store가 필요함 → 더 많은 연산이 필요함 Compiler는 가능한 변수들을 다루는데 Register를 사용해야 함 → 자주 사용하지 않는 변수는 memory에 spill → Resiter Optimization은 매우매우 중요함 !📌 Constant(or Immediate) Operands arithmetic instruction 내에 constant(상수)를 포함 → memory에서 load하는 경우보다 더 빠름 MIPS immediate instructions addi $s3, $s3, 4 # $s3 = $s3 + 4 → addi는 있지만 subi는 없다. subi를 구현하고 싶다면? addi $s0, $s1, -10 # $s0 = $s0 + (-10) 📌 The Constant Zero The number zero(0)은 매우 자주 사용되기때문에 $zero(Register 0)로 정의 $zero는 상수 0을 의미 → overwritten ❌ → 이는 하드웨어에 정의되어있기 때문에 addi $0, $0, 5 같은 명령은 아무일도 일어나지 않는다. Common operations에 유용함 → 값 이동(데이터 복사) add $t2, $s1, $zero 📌 MIPS Instruction Fields op : 명령어가 실행할 연산의 종류 → 연산자(opcode)라고 부름 rs : 첫 번째 근원지(source) 피연산자 레지스터 rt : 두 번째 근원지 피연산자 레지스터 rd : 목적지(destination) 레지스터. 연산 결과가 저장됨 shamt(sa) : 자리이동량(shift) funct : 기능(function). op필드에서 연산의 종류를 표시하고, funct 필드에서 그중의 한 연산을 구체적으로 지정.📌 Machine Language Instruction Format R type : add, sub → op, rs, rt, rd, sa, funct I type : load, store, addi → op, rs, rt, immediate Load Instruction lw $t0, 24($s2) Format : I op : 35 rd, sa, funct : n.a(not applicable) → 이 형식에서 사용되지 않음 Store Instruction sw $t0, 24($s2) Format : I op : 43 Immediate Instruction addi $s3, $s3, 4 Format : I op : 8 ‼️ Instruction Format Encoding" }, { "title": "[전자계산기구조] Computer Architecture TA_Week5", "url": "/posts/TA-week5/", "categories": "INU, Computer Architecture", "tags": "ComputerArchitecture, INU, TA", "date": "2021-04-01 15:50:00 +0900", "snippet": "전자계산기구조 TA _ Week5📌 Fundamental Data Types Bit memory의 가장 작은 단위 on / off 또는 1 / 0 상태중 하나를 가질 수 있음 Byte 8bits로 구성 → 256가지의 patterns을 가질 수 있음 CPU는 memory에 있는 byte의 값을 검색할 수 있음 → 주소의 단위가 된다 CPU는 address별로 각 byte를 식별함 Half-word 2Bytes로 구성 short word라고도 알려져있다. Word 4Bytes(32bits)로 구성 📌 Logical / Physical Memory Organization Logical Memory Organization Memory는 주소를 갖는 큰 1차원 배열 Memory address는 배열의 index “Byte addressing”*은 index가 memory의 byte를 가리키는 것을 의미 Physical Memory Organization Bytes는 일반적인 산술 연산을 하기엔 너무 작은 단위 또한 너무 작아서 충분한 명령어를 저장할 수 없음 MIPS에서는 4Byte 단위의 word로 표준을 정함 메모리는 한 word(4Byte) 각각의 워드에 포함하는 주소가 다음과 같이 지정 📌 Data Transfer: Memory to Register 데이터 워드 전송을 위해서 Register 0 - 31 로 명시 Memory Address memory는 주소가 인덱스 역할을 하는 큰 일차원 배열 Offset과 Base Address가 필요함 Load Instruction Syntax lw $t0, 12($s0) lw : Load Word Memory → Register로 데이터를 복사해오는 데이터 전송 명령 연산자 이름 메모리에서 읽어 온 값을 저장 할 Register Memory 접근에 사용할 Offset → 배열의 인덱스에 접근하기 위해 사용 Memory 접근에 사용할 Base Register → 배열의 시작 부분을 가리킴 Store Instruction Syntax sw $t0, 12($s0) sw : Store Word Register → Memory로 데이터를 보내는 데이터 전송 명령 연산자 이름 메모리에서 읽어 온 값을 저장 할 Register Memory 접근에 사용할 Offset Memory 접근에 사용할 Base Register ❗️ Memory Operand Example load, add g = h + A[6] $s1 → g, $s2 → h, $s3 → Base address of A 위 C statement를 MIPS Assembly로 컴파일하면 ? lw $t0, 24($s3) # load word, $t0 = A[6]add $s1, $s2, $t0 # g = h + A[6] load, add, sw A[14] = h + A[6] $s2 → h, $s3 → Base address of A 위 C statement를 MIPS Assembly로 컴파일하면 ? lw $t0, 24($s3) # load word, $t0 = A[6]add $t0, $s2, $t0 # $t0 = h + A[6]sw $t0, 56($s3) # store word, A[14] = $t0 = h + A[6] load, sub, sw A[8] = A[2] - b $s2 → b, $s3 → Base address of array A 위 C statement를 MIPS Assembly로 컴파일하면 ? lw $t0, 8($s3) # load word, $t0 = A[2]sub $t0, $t0, $s2 # $t0 = $t0 - bsw $t0, 32($s3) # store word, A[8] = $t0 = A[2] - b 📌 Accessing Memory MIPS → two basic data transfer instructions → lw(load), sw(store) 데이터 전송 명령에서 명시할 것 Memory에서 load / store 할 위치 → Memory address Register file에서 load / store를 수행 할 위치 → Register Destination(source) Memory address는 Offset과 Base Register의 sum으로 형성한다." }, { "title": "[전자계산기구조] Computer Architecture TA_Week4", "url": "/posts/TA-week4/", "categories": "INU, Computer Architecture", "tags": "ComputerArchitecture, INU, TA", "date": "2021-03-22 15:50:00 +0900", "snippet": "📌 MIPS Instructions1. Addition add : 수행할 연산을 나타내는 명령어로, 덧셈을 의미 b, c : 계산을 수행할 피연산자들 a : 명령을 수행하고 나온 결과를 저장할 피연산자 다음 High-level code를 MIPS assembly로 컴파일하면? → x = y + z ; → c = a + b ;2. Subtraction Subtraction은 Addition과 유사하게 동작되며, 명령어만 다름 sub : 수행할 연산을 나타내는 명령어로, 뺄셈을 의미 b, c : 계산을 수행할 피연산자들 a : 명령을 수행하고 나온 결과를 저장할 피연산자 다음 High-level code를 MIPS assembly로 컴파일하면? → x = y - z ; → c = a - b ;3. More Complex Code Complex Code는 multiple MIPS Instruction으로 표현 가능 Design Principle 1을 도출할 수 있음📌 Design Principle1. 간단하게 하기 위해서는 규칙적인 것이 좋다. 반드시 한 종류의 연산만 지시하는 instruction format을 유지. 모든 명령어가 3개의 피연산자를 갖도록 함. → 2 sources, 1 destination → hardware에서 encode, handle을 쉽게 하기 위함 간단하게 만들어야 낮은 가격의 머신에서도 높은 성능을 끌어올릴 수 있음.2. 일반적인 경우(Common case)를 빠르게 해라. 상수 피연산자의 경우, 자주 사용되므로 상수 필드를 가진 산술 명령어를 사용하면 매번 메모리에서 상수를 가져오는 것보다 연산이 훨씬 빨라지고 간단해지고 에너지를 덜 소모함. → Immediate operand(즉각 연산, 상수)를 사용하면 더 빠르게 동작하게 함. 상수 0은 유용한 여러 변형을 제공 제공함으로써 단순한 명령어 집합을 가능케 함. 3. 작은것이 더 빠르다. MIPS instruction의 피연산자에는 제약이 있는데, 소수의 Register만 사용 가능하다. 테이블에 있는 몇 권의 책에서 데이터를 검색하는 것이 1000권의 책을 정렬하는 것보다 빠르듯이, 32개의 레지스터에서 데이터를 검색하는 것이 1000개의 레지스터나 대용량 메모리에서 데이터를 검색하는 것보다 더 빠름 → 메모리에 직접 접근하는 것보다 레지스터에 접근하는 것이 훨씬 빠르다.📌 Operands 피연산자 : Registers 컴퓨터는 binary operands를 검색할 물리적 위치가 필요함. 컴퓨터가 피연산자를 검색 : Register / Memory / Constants (immediates라고 불림) Main memory 복합 데이터를 다뤄서 느려요 대부분의 Architecture는 작은(빠른) register 집합이 있음(MIPS는 32-bit register를 가짐) MIPS는 32-bit Architecture라고 불림(32-bit data에서 동작하므로) → 64-bit version인 MIPS도 있지만, 우리는 32-bit version만 볼거에용. 이름 앞에 달러 기호($)를 사용하며 쓰임. → $s0는 레지스터 0으로 쓰이고 register zero, dollar zero라고 함 특정 용도로 사용되는 레지스터 $s0 : 상수 0 $s0 ~ $s7 : 변수를 저장할 때 사용되는 saved registers $t0 ~ $t9 : complex instruction에서 많은 계산을 하는 동안 중간 값을 저장하기 위해 사용되는 temporary register 📌 MIPS Arithmetic Instructionadd $t0, $s1, $s2sub $t0, $s1, $s2 각 산술 명령은 하나의 연산만 수행하게 됨. 각 산술 명령은 3개의 피연산자를 가짐(Design Principle 1) source1 op source2 → destination 피연산자의 순서는 첫번째가 destination, 그 다음에 source1, source2가 온다. 피연산자는 datapath의 register file($t0, $s1, $s2)에 포함됨.Compiling more Complex Statementsh = ( b - c ) + d C Statement를 assembler로 변환하면? variable b는 $s1에, c는 $s2, d는 $s3, 연산 결과는 $s0에 저장한다고 하면 sub $t0, $s1, $s2 add $s0, $t0, $s3 📌 MIPS Register File 32개의 32-bit registers를 갖는다. 2개의 read 포트(src1 addr, src2 addr) 1개의 write 포트(dst addr) 32개의 레지스터 주소(0~31)을 위한 것이므로, 각각 5bit($2^5 -1$)만 담을 수 있어도 충분해 레지스터는 ?! 빠르다. → 작을수록 더 빠르고, 일반적인 경우를 빠르게 함. → 하지만 구성되는 레지스터의 수가 많을수록 속도 저하됨. compiler를 사용하기에 더 용이하다. → (A * B) - (C * D) - (E * F)는 어느 순서로든 연산 가능함 코드의 밀도를 향상시킨다. → 레지스터는 메모리보다 적은 비트수로 불리기 때문에(5 bits &amp;lt; 32bits) 레지스터 주소는 $를 이용하여 나타낸다.❗️ExampleHow to do the following C statement ?use intermediate temporary register $t0, $t1→ Assembly codeadd $t0, $s1, $s2add $t1, $s3, $s4sub $s0, $t0, $t1" }, { "title": "[컴퓨터알고리즘 12주차 OJS] 통 채우기(Bin Packing)", "url": "/posts/binpacking/", "categories": "INU, Computer algorithm", "tags": "algorithm, java", "date": "2020-06-05 00:15:00 +0900", "snippet": "통 채우기 문제컴퓨터알고리즘 교재 과제 문제풀이입니다.우선, Fit이라는 인터페이스를 통해서 기본 틀을 만들어준 후 First, Next, Best, Worst Fit에서 Fit을 상속받아 메소드 오버라이딩을 통해 코드를 구현하였다.Fit은 다음과 같이 정의되었다.import java.util.ArrayList;public interface Fit { public void fit(ArrayList&amp;lt;Bin&amp;gt; arr, Item item);} First Fit, 최초 적합첫 번째 통부터 차례로 살펴보며 가장 먼저 여유가 있는 통에 새 물건을 넣는다.결과는 다음과 같이 나온다. import java.util.ArrayList; public class FirstFit implements Fit { @Override public void fit(ArrayList&amp;lt;Bin&amp;gt; arr, Item item) { for (int i=0; i&amp;lt;arr.size(); i++) { Bin bin = arr.get(i); if(bin.check(item)) { bin.update(item); return; } } Bin b = new Bin(); b.update(item); arr.add(b); } } Next Fit, 다음 적합직전에 물건을 넣은 통에 여유가 있으면 새 물건을 넣는다.결과는 다음과 같이 나온다. import java.util.ArrayList; public class NextFit implements Fit{ @Override public void fit(ArrayList&amp;lt;Bin&amp;gt; arr, Item item) { Bin bin = new Bin(); if(arr.size() == 0){ bin.update(item); arr.add(bin); } else { bin = arr.get((arr.size())-1); if(bin.check(item)) bin.update(item); else { Bin b = new Bin(); b.update(item); arr.add(b); } } } } Best Fit, 최선 적합기존의 통 중에서 새 물건이 들어가면 남는 부분이 가장 적은 통에 새 물건을 넣는다.결과는 다음과 같이 나온다. import java.util.ArrayList; public class BestFit implements Fit { @Override public void fit(ArrayList&amp;lt;Bin&amp;gt; arr, Item item) { Bin bin = new Bin(); if(arr.size() == 0){ bin.update(item); arr.add(bin); return; } else { int min = 10; for (int i = 0; i &amp;lt; arr.size() ; i++) { bin = arr.get(i); if(bin.check(item)) { if (min &amp;gt; bin.remainCapacity - item.weight) min = i; } } // 다 돌았는데 넣을 곳이 없었다 ? 그러면 통 새로 만들어서 넣어주기 if(min == 10) { bin = new Bin(); bin.update(item); arr.add(bin); } // min의 값이 바뀌었다면 어딘가에 얘를 최선으로 넣었다는거지 else { bin = arr.get(min); bin.update(item); } } } } Worst Fit, 최악 적합기존의 통 중에서 새 물건이 들어가면 남는 부분이 가장 큰 통에 새 물건을 넣는다.결과는 다음과 같이 나온다. import java.util.ArrayList; public class WorstFit implements Fit { @Override public void fit(ArrayList&amp;lt;Bin&amp;gt; arr, Item item) { Bin bin = new Bin(); if(arr.size() == 0){ bin.update(item); arr.add(bin); return; } else { int max = -1; for (int i = 0; i &amp;lt; arr.size() ; i++) { bin = arr.get(i); if(bin.check(item)) { if (max &amp;lt; bin.remainCapacity - item.weight) max = i; } } // 다 돌았는데 넣을 곳이 없었다 ? 그러면 통 새로 만들어서 넣어주기 if(max == -1) { bin = new Bin(); bin.update(item); arr.add(bin); } // max의 값이 바뀌었다면 최악으로 들어갈 곳을 찾았다는거지 else { bin = arr.get(max); bin.update(item); } } } } " }, { "title": "[컴퓨터알고리즘 5주차 OJS] 탐욕 알고리즘(Greedy)", "url": "/posts/OJS2/", "categories": "INU, Computer algorithm", "tags": "algorithm, java", "date": "2020-04-20 23:30:00 +0900", "snippet": "OJS 5주차 문제풀이컴퓨터알고리즘 OJS 과제 문제풀이입니다. 급료 계산사실 이거 망했다. OJS는 통과했지만 백준은 통과하지못한 덜떨어진 코드.어디가 문제인지도 알지만 아직 귀찮아서 수정 안함 ^^~입력으로 1원 9개 5원 3개 10원 1개이고 최저임금이 7원이라하면 4명이 고용되어야하지만 나는 3명이 고용되지롱 ,,,1원과 5원의 조합을 생각하지 않아서 생기는 문제. 중간고사 끝나고 수정하겠음 ㅠ_ㅠ일단 통과한 코드는 이렇다 import java.util.*; public class G { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int employ = 0; int n = scanner.nextInt(); int c = scanner.nextInt(); int arr[][] = new int[n][2]; for(int i = 0 ; i &amp;lt; n ; i++){ arr[i][0] = scanner.nextInt(); arr[i][1] = scanner.nextInt(); } Arrays.sort(arr, new Comparator&amp;lt;int[]&amp;gt;(){ @Override public int compare(int[] a, int[]b){ return Integer.compare(a[1], b[1]); } }); for(int i = n-1 ; i &amp;gt;= 0 ; i--){ while(true){ if(arr[i][1] == 0) break; if(arr[i][0] &amp;gt;= c) { arr[i][1]--; employ++; } else { if(arr[i][0]*arr[i][1] &amp;lt; c) break; int coin = arr[i][0]; int cnt = 1; while(coin &amp;lt; c) { coin += arr[i][0]; cnt++; } arr[i][1] -= cnt; employ++; } } } System.out.println(employ); } } 회의실 배정나름 재미있는 문제였다. ㅋㅋㅋㅋ그림까지 그려가며 슥슥 푼 문제. import java.util.*; class Time { int start; int end; public Time(int start, int end){ this.start = start; this.end = end; } public int getStart() { return start; } public int getEnd() { return end; } } public class H { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); Vector&amp;lt;Time&amp;gt; arr = new Vector&amp;lt;Time&amp;gt;(); for (int i = 0 ; i &amp;lt; n ; i++) { int s = scanner.nextInt(); int e = scanner.nextInt(); arr.add(new Time(s, e)); } Collections.sort(arr, new Comparator&amp;lt;Time&amp;gt;() { @Override public int compare(Time o1, Time o2) { if (o1.getEnd() == o2.getEnd()) { return o1.getStart() - o2.getStart(); } else { return o1.getEnd() - o2.getEnd(); } } }); int cnt = 0; int e = -1; for(int i = 0 ; i &amp;lt; n ; i++){ if(arr.get(i).getStart() &amp;gt;= e){ e = arr.get(i).getEnd(); cnt++; } } System.out.println(cnt); } } 신입사원서류순으로 정렬 후 면접점수만 돌면서 카운트 증가시켜주면 끝나는 문제였다. import java.util.*; class Grade { int document; int interview; public Grade (int document, int interview){ this.document = document; this.interview = interview; } public int getDocument() { return document; } public int getInterview() { return interview; } } public class I { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int i = 0 ; i &amp;lt; t ; i++){ Vector&amp;lt;Grade&amp;gt; grade = new Vector&amp;lt;Grade&amp;gt;(); int n = scanner.nextInt(); for(int j = 0 ; j &amp;lt; n ; j++){ int docu = scanner.nextInt(); int inter = scanner.nextInt(); grade.add(new Grade(docu, inter)); } grade.sort((o1, o2) -&amp;gt; o1.document - o2.document); int cnt = 1; Grade start = grade.firstElement(); for(Grade saram : grade){ if(saram.getInterview() &amp;lt; start.getInterview()){ start = saram; cnt++; } } System.out.println(cnt); } } } " }, { "title": "[컴퓨터알고리즘 5주차 OJS] 탐욕 알고리즘(Greedy) - Programmers 문제", "url": "/posts/greedy-assignment/", "categories": "INU, Computer algorithm", "tags": "algorithm, java", "date": "2020-04-19 01:30:00 +0900", "snippet": "탐욕 알고리즘 Greedy AlgorithmProgrammers 코딩테스트 연습 탐욕법 문제 - 단속카메라문제 설명고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다. 고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.제한사항 차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다. 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다. 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.입출력 예시Input :-20,15, -14,-5, -18,-13, -5,-3 Output: 2입출력 예시 설명-5 지점에 카메라를 설치하면 첫 번째, 두 번째, 네 번째 차량이 카메라를 만납니다.-15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다.풀이import java.util.*;public class greedy { public int solution(int[][] routes) { int cnt = 0, position = -30001; // 람다식 사용 Arrays.sort(routes, (a, b) -&amp;gt; Integer.compare(a[1], b[1])); // route[0]은 진입지점, route[1]은 진출지점 for (int[] route : routes) { if (position &amp;lt; route[0]) { position = route[1]; cnt++; } } return cnt; }}" }, { "title": "[Algorithm] 탐욕 알고리즘", "url": "/posts/greedy/", "categories": "Study, Algorithm", "tags": "algorithm, java", "date": "2020-04-18 23:30:00 +0900", "snippet": "탐욕 알고리즘 (Greedy) 탐욕 알고리즘이란 ?욕심쟁이 알고리즘, 탐욕법 등으로도 언급되는 알고리즘. 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다. 최적화 문제를 풀 때 사용되는 알고리즘. 알고리즘의 활용 동전 거스름돈 Coin Change 최소 신장 트리 Minimum Spanning Tree -&amp;gt; 크루스칼 Kruskal, 프림 Prim 최단 경로 찾기 Shortest Path 부분 배낭 문제 Knapsack 집합 커버 문제 SetCover 작업 스케줄링 JobScheduling 허프만 압축 Huffman compression " }, { "title": "[컴퓨터알고리즘 4주차 과제] Swing을 이용한 자판기 팀프로젝트", "url": "/posts/teamproject/", "categories": "INU, Computer algorithm", "tags": "algorithm, java", "date": "2020-04-15 18:30:00 +0900", "snippet": "Vending Machine 제작 Swing을 이용한 GUI 제작 JFrame, JLabel, JButton, ImageIcon, JTextfield, JOptionPane 등을 사용하여 사용자 인터페이스 구현 Event 구현 -/+ 버튼 클릭 JTextfield인 total_out에 총액 더하고 빼준거 set해주기 수량이 0일때 - 버튼 클릭 시 setEnabled false 설정 계산 버튼 클릭 입력한 금액이 총액보다 작을때 잔액부족 팝업 위 조건만 아니면 그리디 알고리즘으로 잔돈 반환 추가 수정사항 [수정] 수량을 -/+ 버튼만으로 조절하는게 아니라 입력할 수 있게 해볼까 .. [수정] 처음 시작할때 -버튼 setEnabled false 설정해주기 " }, { "title": "[Git] Github 명령어", "url": "/posts/github-directions/", "categories": "Study, Git", "tags": "git", "date": "2020-04-15 14:30:00 +0900", "snippet": "깃허브 정리컴퓨터알고리즘 과제 중 혼자 찾아가며 알아간 깃 명령어 정리내용입니다. Git의 기본 Git이란 무엇인가 ?Git이란 souce 관리를 위한 분산 버전 관리 시스템이다.코드를 버전 관리함으로써, 배포후 major 버그를 발생시 빠르게 rollback을 하거나 수정된 코드만을 파악하여, 버그를 빠르게 찾거나, 한 프로젝트의 코드를 여러 사람이 함께 작업 할 수 있도록 도와주는 등 사용하면 많은 이점을 가지고 있다. Repository가 무엇인가 ?말 그대로 저장소를 의미한다. Git은 로컬저장소와 원격저장소 2개를 제공한다. 로컬 저장소(Local Repository) : 내 PC에 파일이 저장되는 개인 전용 저장소 원격 저장소(Remote Repository) : 파일이 원격 저장소 전용 서버에서 관리되며 여러 사람이 함께 공유하기 위한 저장소 Git 명령어 소개 git init : 여기서 init은 “initialize”를 나타낸다. 명령어를 실행하면 해당 디렉토리를 로컬 깃 저장소로 등록시키며 깃 명령어를 사용할 수 있게 된다. git status : 지정된 저장소의 현재 상태를 나타내준다. git add : 이 명령어 뒤에 스테이지에 올릴 파일명을 적어 작업을 진행한다. git add .이나 git add -all을 하게되면 변경된 파일 모두 스테이지에 올라간다. git commit -m &quot;message&quot; : 로컬 저장소의 최종 단계에 파일을 등록시킨다. -m 뒤에 커밋 메시지를 작성해 알아보기 쉽게 커밋시킨다. 커밋을 하면 작업공간(working tree)는 비워진다. git commit --amend -m &quot;message&quot; : 마지막 커밋 메시지를 message로 수정한다. git remote add ~ : 이는 현재의 로컬 저장소를 깃허브에 있는 저장소에 연결하기 위한 명령어. ~에는 연결하고싶은 저장소의 주소를 입력한다. git remote rm [원격 저장소 이름] : 원격 저장소를 제거해준다. git remote -v : 원격 저장소에 연결이 잘 되어있는지 확인하기 위한 명령어. 명령어를 치면 현재 로컬 저장소와 연결된 저장소의 url이 반환된다. git push [원격 저장소이름] [push하게 될 브랜치 이름] : 로컬 저장소에 있던 파일들을 원격 저장소로 브랜치를 통해 올리게 된다. git clone ~ : 현재 디렉토리에 ~에 입력하게 될 깃허브의 저장소를 그대로 복사해준다. git branch : 생성된 branch들을 확인할 수 있다. git branch [브랜치 이름] : [브랜치이름]을 가진 새로운 브랜치를 생성한다. git branch -r : 원격 branch들을 확인할 수 있다. git branch -a : 로컬 branch들을 확인할 수 있다. git branch -d [브랜치 이름] : [브랜치이름]을 가진 브랜치를 삭제한다. git pull : 원격 저장소에 있는 데이터를 로컬 저장소에 가져와 병합한다. git fetch : 원격 저장소에 있는 데이터를 로컬 저장소에 가져와 저장한다.(병합 x) git reset -[옵션] [돌아갈 커밋] : [돌아갈 커밋] 버전으로 되돌려준다. 옵션에 따라 어떻게 되돌아가는지에 차이가 있다. hard : [돌아갈 커밋]으로 돌아가며 이후의 커밋을 모두 삭제한다. soft : [돌아갈 커밋] 으로 돌아가지만 이후의 커밋과 인덱스는 그대로 남아있다. " }, { "title": "[컴퓨터알고리즘 3주차 과제] Strassen Algorithm 알아보기", "url": "/posts/strassen-algorithm/", "categories": "INU, Computer algorithm", "tags": "algorithm, java", "date": "2020-04-07 12:30:00 +0900", "snippet": "컴퓨터알고리즘 개인 과제인 Strassens Algorithm 조사내용입니다.Markdown에서의 수식작성은 위키백과:Tex 문법 참고Strassen Algorithm (슈트라센 알고리즘)선형대수학에서 슈트라센 알고리즘은 독일의 수학자 폴커 슈트라센(Volker Strassen)이 1969년에 개발한 행렬 곱셈 알고리즘이다.정의에 따라 n×n 크기의 두 행렬을 곱하면 O($n^3$)의 시간이 소요되지만 이 알고리즘은 대략 O($n^{2.807}$)의 시간이 소요된다.알고리즘 설명$A$와 $B$를 체 $F$에 대한 정사각행렬이라고 하자. 두 행렬의 곱 C는 다음과 같다.\\[C=AB \\qquad\\qquad A, B, C \\in F^{2^n \\times 2^n}\\]만약 $A$와 $B$가 $2^n \\times 2^n$ 꼴의 크기가 아니라면 먼저 모자라는 행과 열을 0으로 채운다. 이 경우 행렬 곱셈이 끝난 뒤 행렬에서 필요한 부분만 다시 잘라 내야 한다.이제 A, B, C를 같은 크기의 정사각행렬 네 개로 나눈다.\\[A=\\begin{bmatrix} A_{1,1} &amp;amp; A_{1,2}\\\\ A_{2,1} &amp;amp; A_{2,2} \\end{bmatrix}, B = \\begin{bmatrix} B_{1,1} &amp;amp; B_{1,2}\\\\ B_{2,1} &amp;amp; B_{2,2} \\end{bmatrix}, C = \\begin{bmatrix} C_{1,1} &amp;amp; C_{1,2}\\\\ C_{2,1} &amp;amp; C_{2,2} \\end{bmatrix}\\]이때,\\[A_{i, j}, B_{i, j}, C_{i, j} \\in F^{2^{n-1} \\times 2^{n-1}}\\]따라서 다음이 성립한다.\\[C_{1,1} = A_{1,1}B_{1,1} + A_{1,2}B_{2,1}\\]\\[C_{1,2} = A_{1,1}B_{1,2} + A_{1,2}B_{2,2}\\]\\[C_{2,1} = A_{2,1}B_{1,1} + A_{2,2}B_{2,1}\\]\\[C_{2,2} = A_{2,1}B_{1,2} + A_{2,2}B_{2,2}\\]이 과정에서는 필요한 연산의 수가 줄어 들지 않는다. 여전히 $C_{i,j}$행렬을 계산하려면 여덟 번의 곱셈과 네 번의 덧셈이 필요하다.이제 다음과 같은 행렬을 정의한다.\\[M_1 := (A_{1,1} + A_{2,2})(B_{1,1} + B_{2,2})\\]\\[M_2 := (A_{2,1} + A_{2,2})B_{1,1}\\]\\[M_3 := A_{1,1}(B_{1,2} - B_{2,2})\\]\\[M_4 := A_{2,2}(B_{2,1} - B_{1,1})\\]\\[M_5 := (A_{1,1} + A_{1,2})B_{2,2}\\]\\[M_6 := (A_{2,1} - A_{1,1})(B_{1,1} + B_{1,2})\\]\\[M_7 := (A_{1,2} - A_{2,2})(B_{2,1} + B_{2,2})\\]이 $M_k$ 행렬들은 $C_{i,j}$ 행렬을 표현하는 데 쓰이는데, 이 행렬들을 계산하는 데는 일곱 번의 곱셈(각 변수마다 한 번씩)과 10번의 덧셈이 필요하다. 이제 $C_{i,j}$ 행렬은 다음과 같이 표현할 수 있다.\\[C_{1,1} = M_1 + M_4 - M_5 + M_7\\]\\[C_{1,2} = M_3 + M_5\\]\\[C_{2,1} = M_2 + M_4\\]\\[C_{2,2} = M_1 - M_2 + M_3 + M_6\\]이 과정에서는 곱셈이 사용되지 않기 때문에, 전체 곱셈을 일곱 번의 곱셈과 18번의 덧셈으로 처리할 수 있다. 큰 행렬에 대해서는 행렬의 곱셈이 덧셈보다 더 많은 시간을 필요로 하기 때문에 덧셈을 더 하는 대신 곱셈을 덜 하는 것이 전체적으로 더 효율적이다.이 과정을 재귀적으로 반복할 경우 총 $7 \\cdot n^{\\log_{2}7} - 6 \\cdot n^2$ 번의 연산이 필요하다. $\\log_{2} 7$ = $2.807 \\cdots$ 이므로 전체 수행 시간은 약 O($n^{2.807}$)이다.실제로 n이 작을 경우 정의에 따라 행렬 곱셈을 하는 경우가 빠를 수도 있기 때문에, 보통 작은 n에 대해서는 일반적인 방법으로 곱셈을 하도록 구현한다.슈트라센 알고리즘은 속도에 비해 수치 안정성이 떨어지는 것으로 알려져 있다. 두 행렬 $A$와 $B$를 곱한 결과를 $C$라 할 때, 실제 오차인 $\\lVert C - AB \\rVert$는 $27n^2u\\lVert A \\rVert \\lVert B \\rVert + O(u^2)$ 보다 작음이 알려져 있다. 이는 일반적인 행렬 곱셈보다 더 큰 오차이다.아래 코드는 Google에 Strassen Algorithm java를 검색하면 나오는 소스코드이다. 혼자 짜보려다 실패해서 아래 코드를 따라쳐 이해하며 만들었다 … 길어보이긴 하지만 생각보다 어렵진않다.import java.util.Scanner; /** Class Strassen **/public class Strassen{ /** Function to multiply matrices **/ public int[][] multiply(int[][] A, int[][] B) { int n = A.length; int[][] R = new int[n][n]; /** base case **/ if (n == 1) R[0][0] = A[0][0] * B[0][0]; else { int[][] A11 = new int[n/2][n/2]; int[][] A12 = new int[n/2][n/2]; int[][] A21 = new int[n/2][n/2]; int[][] A22 = new int[n/2][n/2]; int[][] B11 = new int[n/2][n/2]; int[][] B12 = new int[n/2][n/2]; int[][] B21 = new int[n/2][n/2]; int[][] B22 = new int[n/2][n/2]; /** Dividing matrix A into 4 halves **/ split(A, A11, 0 , 0); split(A, A12, 0 , n/2); split(A, A21, n/2, 0); split(A, A22, n/2, n/2); /** Dividing matrix B into 4 halves **/ split(B, B11, 0 , 0); split(B, B12, 0 , n/2); split(B, B21, n/2, 0); split(B, B22, n/2, n/2); /** M1 = (A11 + A22)(B11 + B22) M2 = (A21 + A22) B11 M3 = A11 (B12 - B22) M4 = A22 (B21 - B11) M5 = (A11 + A12) B22 M6 = (A21 - A11) (B11 + B12) M7 = (A12 - A22) (B21 + B22) **/ int [][] M1 = multiply(add(A11, A22), add(B11, B22)); int [][] M2 = multiply(add(A21, A22), B11); int [][] M3 = multiply(A11, sub(B12, B22)); int [][] M4 = multiply(A22, sub(B21, B11)); int [][] M5 = multiply(add(A11, A12), B22); int [][] M6 = multiply(sub(A21, A11), add(B11, B12)); int [][] M7 = multiply(sub(A12, A22), add(B21, B22)); /** C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 - M2 + M3 + M6 **/ int [][] C11 = add(sub(add(M1, M4), M5), M7); int [][] C12 = add(M3, M5); int [][] C21 = add(M2, M4); int [][] C22 = add(sub(add(M1, M3), M2), M6); /** join 4 halves into one result matrix **/ join(C11, R, 0 , 0); join(C12, R, 0 , n/2); join(C21, R, n/2, 0); join(C22, R, n/2, n/2); } /** return result **/ return R; } /** Funtion to sub two matrices **/ public int[][] sub(int[][] A, int[][] B) { int n = A.length; int[][] C = new int[n][n]; for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; n; j++) C[i][j] = A[i][j] - B[i][j]; return C; } /** Funtion to add two matrices **/ public int[][] add(int[][] A, int[][] B) { int n = A.length; int[][] C = new int[n][n]; for (int i = 0; i &amp;lt; n; i++) for (int j = 0; j &amp;lt; n; j++) C[i][j] = A[i][j] + B[i][j]; return C; } /** Funtion to split parent matrix into child matrices **/ public void split(int[][] P, int[][] C, int iB, int jB) { for(int i1 = 0, i2 = iB; i1 &amp;lt; C.length; i1++, i2++) for(int j1 = 0, j2 = jB; j1 &amp;lt; C.length; j1++, j2++) C[i1][j1] = P[i2][j2]; } /** Funtion to join child matrices intp parent matrix **/ public void join(int[][] C, int[][] P, int iB, int jB) { for(int i1 = 0, i2 = iB; i1 &amp;lt; C.length; i1++, i2++) for(int j1 = 0, j2 = jB; j1 &amp;lt; C.length; j1++, j2++) P[i2][j2] = C[i1][j1]; } /** Main function **/ public static void main (String[] args) { Scanner scan = new Scanner(System.in); System.out.println(&quot;Strassen Multiplication Algorithm Test\\n&quot;); /** Make an object of Strassen class **/ Strassen s = new Strassen(); System.out.println(&quot;Enter order n :&quot;); int N = scan.nextInt(); /** Accept two 2d matrices **/ System.out.println(&quot;Enter N order matrix 1\\n&quot;); int[][] A = new int[N][N]; for (int i = 0; i &amp;lt; N; i++) for (int j = 0; j &amp;lt; N; j++) A[i][j] = scan.nextInt(); System.out.println(&quot;Enter N order matrix 2\\n&quot;); int[][] B = new int[N][N]; for (int i = 0; i &amp;lt; N; i++) for (int j = 0; j &amp;lt; N; j++) B[i][j] = scan.nextInt(); int[][] C = s.multiply(A, B); System.out.println(&quot;\\nProduct of matrices A and B : &quot;); for (int i = 0; i &amp;lt; N; i++) { for (int j = 0; j &amp;lt; N; j++) System.out.print(C[i][j] +&quot; &quot;); System.out.println(); } }}Enter order n :4Enter N order matrix 12 3 1 64 0 0 24 2 0 10 3 5 2Enter N order matrix 2 3 0 4 31 2 0 20 3 1 45 1 3 2 Product of matrices A and B :39 15 27 2822 2 22 1619 5 19 1813 23 11 30" }, { "title": "[컴퓨터알고리즘 4주차 OJS] 분할 정복 알고리즘(Divide&amp;Conquer)", "url": "/posts/OJS1/", "categories": "INU, Computer algorithm", "tags": "algorithm, java", "date": "2020-04-04 23:30:00 +0900", "snippet": "OJS 4주차 문제풀이컴퓨터알고리즘 OJS 과제 문제풀이입니다. a^b 경우를 2가지로 나누어 풀었다. b가 홀수일때 : $ a \\times a^{b-1} $ b가 짝수일때 : $ a^{b/2} \\times a^{b/2}$ 여기서 b가 짝수일때 $a^{b/2}$를 두번 호출하는게 아니라 $a^{b/2}$결과값을 변수에 저장 후 그 변수를 곱해줘야 시간복잡도가 줄어들..걸..? import java.util.*; import java.math.*; class Result { public BigDecimal pow(BigDecimal a, int b){ if( b == 0 ) return a.ONE; else if( b == 1 ) return a; else if( b % 2 == 1 ){ // 지수가 홀수면 a*a^b-1으로 b를 짝수로 ㄱ return a.multiply(pow(a,b-1)); } else { // 지수가 짝수니까 분할 BigDecimal k = pow(a, b/2); return k.multiply(k); } } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); Result res = new Result(); double a = scanner.nextDouble(); int b = scanner.nextInt(); // BigDecimal의 매개변수는 문자열로 와용 BigDecimal bd = new BigDecimal(String.valueOf(a)); BigDecimal result = res.pow(bd, b); System.out.println(result.toPlainString()); } } 용돈 관리2학기 데이터 구조때 한번 풀었던 문제라 별 생각없이 슥슥 푼 문제. 사실 풀이를 외우다시피 한 문제라 생각없이 풀었지 아무것도 모르는 상태였으면 잘 못풀었을듯한 문제. import java.util.*; public class Main{ public static void main(String args[]){ Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); int arr[] = new int[n]; int low = 0; int high = 0; for(int i = 0 ; i &amp;lt; n ; i ++){ arr[i] = scanner.nextInt(); if(arr[i] &amp;gt; low) low = arr[i]; // 최소값 찾는 과정 high += arr[i]; } while(low &amp;lt;= high){ int mid = (low + high) / 2; // 일단 중간값을 임의로 지정해줌 int sum = 0, cnt = 0; for(int i = 0 ; i &amp;lt; n ; i++ ){ if(sum + arr[i] &amp;gt; mid){ sum = 0; cnt++; } sum += arr[i]; } if(sum != 0) cnt++; if(cnt &amp;lt;= m) high = mid-1; // cnt&amp;lt;=m이면 low~mid 부분을 볼거임 else low = mid + 1; // 아니면 mid~high 부분을 볼거임 } System.out.print(low); // 그래서 최저 K 출력 } } 석판 자르기진짜 풀면서 제일 많이 욕한 문제. ㅋㅋㅋㅋㅋㅋ다신 하고싶지 않았던 삽질. 생각보다 로직은 간단했지만 구현면에서 제일 짜증났고 그놈의 가로세로와 불순물 체크때문에 짜증났음. 풀면서 이해하랴 아이패드에서 삽질하랴 짜증이 2배라 한번에 이해하려고 주석까지 달아버림 import java.util.*; class Point { int x; int y; public Point(int x, int y){ this.x = x; this.y = y; } public int getX(){ return this.x; } public int getY(){ return this.y; } } public class Main { // main에서 입력받은 배열, x의 시작점, y의시작점, x의 끝점, y의 끝점, 방향(가로 0, 세로 1)순서대로 인자값 받음 public static int cut(int stone[][], int sx, int sy, int ex, int ey, int direction){ // 가변 길이 배열 생성. Point 객체를 타입으로 지정해줌(x,y값을 받아 저장함) Vector&amp;lt;Point&amp;gt; pv = new Vector&amp;lt;Point&amp;gt;(); int gem = 0; // 보석 개수 카운트할 변수 gem // 입력받은 배열 전부 돌아보자 for(int i = sx ; i &amp;lt; ex ; i++ ){ for(int j = sy ; j &amp;lt; ey ; j++ ){ // 만약 불순물이 걸리면 if(stone[i][j] == 1) { // 불순물의 좌표를 가변 길이 배열인 pv에 넣어줌 pv.add(new Point(i,j)); } // 만약 보석이 걸리면 else if(stone[i][j] == 2) gem++; // 보석의 개수 증가시켜줌 } } if(gem == 0) return 0; // 보석이 0개면 0 리턴함 if(gem == 1) if(pv.size() == 0) return 1; // 보석이 1개이고 불순물이 없다면 1 리턴함. // 결과값 출력해줄 변수. cut이 계속 재귀적으로 호출되니까 ? 초기화도 계속 해쥬자 int result = 0; // 석판을 가로로 잘라보자 if(direction == 0){ // for-each문으로 pv(불순물의 좌표) 순회 for(Point p : pv){ // 불순물의 x, y 좌표 받아오기 int x = p.getX(); int y = p.getY(); // 불순물이 있는 라인을 자를건데 그때 보석이 있는지 확인해줄 변수 int check = 0; // 불순물이 있는 라인에 보석이 있으면 check를 1로 바꿔주자 for(int j = sy ; j &amp;lt; ey ; j++){ if(stone[x][j] == 2) check = 1; } // check가 1이 아니면 ? 불순물이 있는 라인에 보석이 없으면 ! 가로로 자를거니까 다음 석판은 세로로 자르라고 던져주자 if(check != 1) result += cut(stone, sx, sy, x, ey, 1) * cut(stone, x+1, sy, ex, ey, 1); } } // 석판을 세로로 잘라보자 else { // for-each문으로 pv(불순물의 좌표) 순회 for(Point p : pv){ // 불순물의 x, y 좌표 받아오기 int x = p.getX(); int y = p.getY(); // 불순물이 있는 라인을 자를건데 그때 보석이 있는지 확인해줄 변수 int check = 0; // 불순물이 있는 라인에 보석이 있으면 check를 1로 바꿔주자 for(int j = sx ; j &amp;lt; ex ; j++){ if(stone[j][y] == 2) check = 1; } // check가 1이 아니면 ? 불순물이 있는 라인에 보석이 없으면 ! 세로로 자를거니까 다음 석판은 가로로 자르라고 던져주자 if(check != 1) result += cut(stone, sx, sy, ex, y, 0) * cut(stone, sx, y+1, ex, ey, 0); } } return result; } public static void main(String args[]){ Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); // 배열에 석판 정보를 입력받는다 int stone[][] = new int[20][20]; for(int i = 0 ; i &amp;lt; n ; i++ ){ for(int j = 0 ; j &amp;lt; n ; j++ ){ stone[i][j] = scanner.nextInt(); } } // 크게 먼저 가로로 잘랐을때랑 크게 세로로 잘랐을때를 더해주자 int result = cut(stone, 0, 0, n, n, 0) + cut(stone, 0, 0, n, n, 1); if(result == 0) System.out.print(&quot;-1&quot;); else System.out.print(result); } } 가장 가까운 두 점삽질의 끝. 알고리즘 생각했는데 하루종일 구현 못해서 멘탈 터졌음. 예시 다 만들어서 아이패드에서 하나하나 다 삽질했는데 구현에서 막히고 막혀서 오빠한테 헬프쳤더니 오빠가 3이하로는 다 노가다 시키고 그 이후로만 분할정복하면 코드짜기쉬울거라해서 그대로 짰더니 1시간도 안걸려 뚝-딱 … 온전히 내힘으로 했다고 할 순 없는 문제풀이 .. 나는 언제 코딩 늘지 .. ? import java.util.*; class Point { int x; int y; public Point(){} public Point(int x, int y){ this.x = x; this.y = y; } } public class Main{ public static int getDis(Point p, Point q){ return (p.x-q.x)*(p.x-q.x) + (p.y-q.y)*(p.y-q.y); } public static class xsort implements Comparator&amp;lt;Point&amp;gt; { @Override public int compare(Point p, Point q) { return p.x - q.x; } } public static class ysort implements Comparator&amp;lt;Point&amp;gt; { @Override public int compare(Point p, Point q) { return p.y - q.y; } } public static int dac(List&amp;lt;Point&amp;gt; p, int x1, int x2){ int num = x2 - x1 + 1; if(num &amp;lt;= 3) { //n이 3이하면 삽질 int ans = -1; for(int i = x1 ; i &amp;lt;= x2 ; i++) { for(int j = i+1 ; j &amp;lt;= x2 ; j++) { int k = getDis(p.get(i), p.get(j)); if(ans == -1 || ans &amp;gt; k) ans = k; } } return ans; } // 중간 인덱스 찾고 int mid = (x1+x2)/2; // 왼쪽 분할해서 보고 int left = dac(p, x1, mid); // 오른쪽 분할해서 볼거야 int right = dac(p, mid+1, x2); // 왼쪽과 오른쪽중에 더 가까운 거리를 저장 int result = Math.min(left, right); List&amp;lt;Point&amp;gt; pl = new ArrayList&amp;lt;Point&amp;gt;(); for(int i = x1 ; i &amp;lt;= x2 ; i++ ){ // x좌표 거리만 봤을때 더 작으면 일단 넣어 int dis = p.get(i).x - p.get(mid).x; if(dis*dis &amp;lt; result) pl.add(p.get(i)); } pl.sort(new ysort()); // 그리고 y좌표 거리만 보는거지 이미 x로는 추려냈으니깡 for(int i = 0 ; i &amp;lt; pl.size()-1 ; i++ ){ for(int j = i+1 ; j &amp;lt; pl.size(); j++ ){ int dis = pl.get(i).y - pl.get(j).y; if(dis*dis &amp;lt; result){ int jjin = getDis(pl.get(i), pl.get(j)); if(jjin &amp;lt; result) result = jjin; } else break; } } return result; } public static void main(String args[]){ Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); // 좌표 저장하는 Point 객체 배열 List&amp;lt;Point&amp;gt; p = new ArrayList&amp;lt;&amp;gt;(); // x, y 좌표 저장 for(int i = 0 ; i &amp;lt; n ; i++ ){ int x = scanner.nextInt(); int y = scanner.nextInt(); p.add(new Point(x, y)); } // x좌표 기준으로 오름차순 정렬 ! p.sort(new xsort()); System.out.println(dac(p, 0, n-1)); } } " }, { "title": "[Algorithm] 분할 정복 알고리즘", "url": "/posts/Divide-and-Couquer/", "categories": "Study, Algorithm", "tags": "algorithm", "date": "2020-04-03 23:00:00 +0900", "snippet": "분할 정복 알고리즘(Divide and Conquer) 분할정복 알고리즘이란 ?문제를 나눌 수 없을 때까지 나누어 각각을 쪼개서 풀고, 결과를 합병하여 해답을 얻는 알고리즘 ! 퀵소트나 합병정렬이 분할정복의 예시 ! 어떻게 구현하게유 ?Divide and Conquer ! 말 그대로 구현하면 됩니당 ! 나누고 나누고 나누다가 -&amp;gt; Divide 나눌 수 없으면 문제를 풀고 -&amp;gt; Conquer 푼 문제들을 다시 합병해서 출력해주거나 변수에 넣어주는 그런 방식이야 " }, { "title": "[컴퓨터알고리즘 3주차] minimal-mistakes theme 적용", "url": "/posts/theme/", "categories": "INU, Computer algorithm", "tags": "git, jekyll, ruby", "date": "2020-04-03 10:30:00 +0900", "snippet": "Minimal mistakes theme 적용하기저번주 과제로 newpost 자유주제 작성해오기에서 2주차 수업내용을 작성해보니 수업내용 정리하면서 했던거 슥슥 보는것도 재밌고, 장성우 김병헌 이상진 정준수꺼 뚱땅뚱땅 고치다보니 정리해놓으면 좋을 것 같아서 시간 남길래 적는 3주차 수업 ! Minimal mistakes 테마를 git 저장소에서 현재 폴더로 clone 해오자 git clone https://github.com/mmistakes/minimal-mistakes.git 다운받은 Minimal mistakes 폴더에서 파일 및 폴더들을 삭제하자 .editorconfig .gitattributes .github .git (숨김파일 보기 눌러서 꼭 삭제해주기) /docs /test CHANGELOG.md minimal-mistakes-jekyll.gemspec README.md screenshot-layouts.png screenshot.png 삭제하고 남은 파일 및 폴더들을 my-awesome-site 폴더에 붙여넣어주자 Gemfile을 수정하자 source &quot;https://rubygems.org&quot; gem &quot;github-pages&quot;, group: :jekyll_plugins gem &quot;tzinfo-data&quot; gem &quot;wdm&quot;, &quot;~&amp;gt; 0.1.1&quot; if Gem.win_platform? # If you have any plugins, put them here! group :jekyll_plugins do gem &quot;jekyll-paginate&quot; gem &quot;jekyll-sitemap&quot; gem &quot;jekyll-gist&quot; gem &quot;jekyll-feed&quot; gem &quot;jekyll-include-cache&quot; gem &quot;jekyll-algolia&quot; end _config.yml을 열어 수정하자 url : https://[계정명].github.io repository : [계정명]/[계정명].github.io title, name, author은 자기 맴대루~ _posts 폴더 내의 작성한 post들과 page들의 layout을 single로 변경하자 _data 폴더 내의 navigation.yml 파일을 수정하자 title: “About” url : /about/ jekyll 서버를 열고 localhost:4000에서 확인해보자 잘 동작한다면 github에 업로드하기 !" }, { "title": "[컴퓨터알고리즘 2주차 과제] Java 버전에 따른 차이점, 바뀐 내용", "url": "/posts/java/", "categories": "INU, Computer algorithm", "tags": "java", "date": "2020-03-29 23:30:00 +0900", "snippet": "자바 버전에 따른 차이점, 바뀐 내용Java SE 5 2004.09 발표 기능적으로 많은 변화가 생김 Generics, Annotation, Auto Boxing/Unboxing, Enumeration, 가변 길이 파라미터, Static Import, 새로운 Concurrency API 등이 추가 java.util.Scanner가 추가되면서 이전보다 편하게 표준 입력을 사용할 수 있게 되었다.Java SE 6 2006.12 발표 표기가 J2SE에서 Java SE로 바뀌었다. 기능이 추가되었다. 가비지 컬렉터 G1(Garbage first) GC 지원(시험삼아 사용할 수 있게 함)Scripting Language Support, JDBC 4.0, Java Compiler API, Pluggable Annotation 등이 추가 스크립트 언어 지원과 함께 Rhino Javascript 엔진이 기본으로 탑재되었다.Java SE 7 2011.07 발표 정식으로 G1 GC를 지원한다. Java FX가 기본으로 포함되었다. 타입추론 가능 // Java 7 이전 버전List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); // Java 7 이후 버전List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); Switch … case문에서 String 사용 가능 switch(dayoftheweek){ case &quot;sun&quot; : System.out.print(&quot;sun&quot;); case &quot;mon&quot; : System.out.print(&quot;mon&quot;); case &quot;tue&quot; : System.out.print(&quot;tue&quot;); case &quot;wed&quot; : System.out.print(&quot;wed&quot;); case &quot;thur&quot; : System.out.print(&quot;thur&quot;); case &quot;fri&quot; : System.out.print(&quot;fri&quot;); case &quot;sat&quot; : System.out.print(&quot;sat&quot;); } Automatic Resource ManagementJava 7 이전에는 DB Connection, File Stream을 open했을 때 예기치 못한 오류 발생시 정상적인 종료를 위해 finally block에서 close처리를 반드시 해야 했지만 Java 7 에서는 try with resource 구문이 추가되어 자동으로 자원들을 close한다.Java SE 8 2014.03 발표. Oracle 인수 후 처음 발표 된 버전이자 32비트를 지원하는 마지막 공식 Java버전 interface 클래스에 구현체 작성이 가능하게 되었다. default와 static 키워드를 사용해 구현 메소드를 interface에 작성할 수 있게 되었다. GC 성능 대폭 개선 (메소드 영역의 PermGen Area를 제거하여 static 인스턴스와 리터럴 문자열도 GC의 대상이 되도록 바뀌었으며, 클래스, 메소드,배열의 메타 정보는 동적 리사이징이 가능한 Metaspace로 이동시켜 시스템 힙 영역에 저장되기 때문에 JVM 힙 영역의 공간이 늘어나고 PermGen Area를 스캔/삭제할 필요가 없어졌기 때문에 성능이 개선되었음.)Java SE 9 2017.09 발표 Project Jigsaw 기반으로 런타임이 모듈화 되었다. (기본 jar방식을 개선하기위해 등장하였다. 불필요한 라이브러리를 끌어쓰지 않아도 최상위 모듈인 Base만 사용해도 된다.) Java를 인터프리터 언어 셸처럼 사용할 수 있는 JShell가 추가되었다. 그 외에 구조적 불변 컬렉션, 통합 로깅, 프로퍼티 파일에 UTF-8이 지원됨 등이 추가되었다.Java SE 10 2018.03 발표 var 키워드를 이용한 지역 변수 타입 추론이 가능하다. 병렬 처리 가비지 컬렉션이 추가되었다. 그 외에 개별 쓰레드로 분리된 Stop-The-World, JVM 힙 영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당할 수 있게 되는 등 기능이 추가되었다.Java SE 11 2018.09 발표 이클립스 재단으로 넘어간 Java EE가 JDK에서 삭제되고, JavaFX도 JDK에서 분리되어 별도의 모듈로 제공된다. 라이선스 부분에서 가장 큰 변화가 생겼다. Oracle JDK의 독점 기능이 오픈 소스 버전인 OpenJDK에 이식된다. 람다 파라미터에 대한 지역 변수 문법 변경 ‘@Nonnull var x, @Nullable var y’를 x.process(y)로 간략화할 수 있게 되었다. 그 외에 HTTP 클라이언트 표준화, 엡실론 가비지 컬렉터 등의 기능이 추가되었다.Java SE 12 2019.03 발표 Switch문 확장 // 기존의 Switch문 작성 예시switch(day){ case MONDAY : case FRIDAY : case SUNDAY : System.out.println(6); break; case TUESDAY : Sysetm.out.println(7); break; case THURSDAY : case SATARDAY : System.out.println(8); break; case WEDNESDAY : System.out.println(9); break;}// 위의 예시를 확장된 Switch문으로 작성switch(day){ case MONDAY, FRIDAY, SUNDAY -&amp;gt; System.out.println(6); case TUESDAY -&amp;gt; System.out.println(7); case THURSDAY -&amp;gt; System.out.println(8); case WEDNESDAY -&amp;gt; System.out.println(9);} 이 외에 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선의 변경점이 있다.Java SE 13 2019.07 발표 java 12에서의 스위치 개선을 이어 yield 예약어 추가 var a = switch(day){ case MONDAY, FRIDAY, SUNDAY -&amp;gt; yield(6); case TUESDAY -&amp;gt; yield(7); case THURSDAY -&amp;gt; yield(8); case WEDNESDAY -&amp;gt; yield(9);} Java SE 14 2020.03 발표[출처] https://namu.wiki/w/Java#s-4/[나무위키 자바 역사]" }, { "title": "[컴퓨터알고리즘 2주차] Jekyll 설치 및 git repo 연동", "url": "/posts/newpost/", "categories": "INU, Computer algorithm", "tags": "git, jekyll, ruby", "date": "2020-03-23 20:30:00 +0900", "snippet": "20200327 Jekyll 설치저번주 금요일, 컴퓨터 알고리즘 오후반을 수강하고 있는 본인은 Jekyll을 설치하다 극대노 후 자기직전까지 Jekyll만 깔다가 잤다. 경로가 왜 없을까 하다하다 짜증나서 어차피 맥북 한번 밀때가 됐는데 한번 밀어버리자 해서 포맷도 시켜보고 다시 열심히 설치해봤으나 똑같은 warnning과 실패. 이스트소프트에 근무하고 있는 친한 오빠에게 도움을 청하니 10분만에 뚝딱뚝딱 고쳐줬다. 내꺼가 안됐던 이유는 ? 카탈리나 이전의 맥 터미널은 bash 쉘이지만 카탈리나로 업데이트 된 이후로는 터미널이 zsh 쉘로 바뀌었기 때문에 기본 쉘이 zsh로 설정되어있다면 bash 설정이 안먹는다더라 … 모르겠음 난 … 암튼 오빠가 뚱땅뚱땅 고쳐줌. 후에 과제로 자유주제라 하길래 설치했던게 기억에 너무 남길래 Jekyll 설치과정을 포스팅하겟슴당.1. Commnad Line Tools 설치하기xcode-select --install예전에는 Xcode를 깔아야 Command Line Tools를 설치할 수 있었지만 지금은 위의 코드로 설치가 가능하다고 한다.2. 루비 설치하기/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew install rubyHomebrew를 사용하여 최신 버전의 루비를 설치할 수 있다!Jekyll 은 루비 2.4.0 버전을 필요로 하며, 맥OS 카탈리나 10.15 는 루비 2.6.3 이 기본 포함되어 있으므로 아무런 문제가 없지만 이전 버전의 맥OS 시스템을 사용중이라면, 새로운 버전의 루비를 설치해야 한다. (본인은 카탈리나 10.15 사용중이므로 스킵)echo &#39;export PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.bash_profileHomebrew 루비의 경로를 쉘 환경설정에 추가해준다.which ruby# /usr/local/opt/ruby/bin/rubyruby -vruby 2.6.3p62 (2019-04-16 revision 67580)터미널을 재실행하여 추가한 루비 설정을 확인해서 위와 같이 나오면 성공 ~3. Jekyll 설치하기gem install --user-install bundler jekyllBundler과 Jekyll을 로컬 설치해준다.jekyll -v위의 명령어를 통해 잘 설치되었는지 확인하자 !4. Test 만들기jekyll new test-sitecd test-sitebundle exec jekyll serve위의 세 코드를 치면 test-site라는 이름의 블로그를 이용할 수 있게된다.(물론 localhost:4000 으로 사용 가능)20200327 git 연동Github는 고등학교때부터 수행평가 제출, 확인용으로 썼는데 잡다한게 너무 많고 아이디가 ㅋㅋㅋ 고등학교 당시 학번이길래 작년여름에 확인 후 새계정 파버렸다^^* 잘 쓰지는 못하지만 commit과 push는 할 줄 아니까 뭐 코드 날려먹진 않겠지 ㅎㅎㅎ1. git 설치하기brew install git위의 명령어를 이용해 git을 설치해주자 !2. git 연동하기 새로운 레포(Repositories, 저장소) 만들기Github 에 들어가서 로그인 후, 새로운 레포를 만들어주자. 레포 이름은 꼭 ! 꼭 ! /user-name/.github.io 로 만들어야한다. 초기 설정하기 git config --global user.name user-namegit config --global user.email user-emailgit init test-site 위의 두줄 명령어로 사용자의 이름과 이메일을 설정 후, git init 명령어로 test-site에 있는 .git파일을 초기화해준다. 새로 만든 레포와 연결하기 cd test-sitegit add . git commit -m &quot;first commit&quot; git remote add origin https://github.com/user-name/user-name.github.io.git git push -u origin master cd ~~ 명령어로 아까 만든 test-site 디렉토리에 들어간다. git add . 명령어로 현재 디렉토리에 있는 모든 파일을 추가해준다. 여기서 .(all)은 모든 파일을 의미함. git commit -m ~~ 명령어로 commit한다. -m 옵션으로 commit 메시지 작성이 가능함. git remote add origin ~~ 명령어로 로컬 레포에 remote 레포를 등록시켜준다. 뒤에 ~에는 본인이 만든 레포의 주소를 작성함. git push -u origin master 명령어로 깃허브 원격 레포에 로컬 레포에 있던 파일들을 push한다. 여기서 master는 git에서의 master branch를 의미한다. 다음 푸시는 ? git add .git push 위의 두 명령어를 통해 쉽게 레포에 푸시 가능 ! " } ]
